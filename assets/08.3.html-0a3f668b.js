import{_ as l,Z as p,$ as o,a0 as s,a1 as n,a2 as e,a4 as t,H as i}from"./framework-d03928c9.js";const c={},r=s("p",null,"二叉搜索树是一种特殊二叉树:",-1),u=s("ul",null,[s("li",null,"左子节点 < 根节点"),s("li",null,"右子节点 > 根节点")],-1),d={href:"https://en.wikipedia.org/wiki/Computer_science",target:"_blank",rel:"noopener noreferrer"},m=s("strong",null,"binary search tree",-1),v=s("strong",null,"BST",-1),k=s("strong",null,"ordered",-1),g=s("strong",null,"sorted binary tree",-1),h={href:"https://en.wikipedia.org/wiki/Rooted_tree",target:"_blank",rel:"noopener noreferrer"},b={href:"https://en.wikipedia.org/wiki/Binary_tree",target:"_blank",rel:"noopener noreferrer"},f={href:"https://en.wikipedia.org/wiki/Data_structure",target:"_blank",rel:"noopener noreferrer"},x=t(`<p>针对二叉搜索树, 通常使用<strong>中序遍历</strong>, 其遍历结果将是<strong>有序</strong>的.</p><p>由于二叉搜索树的特性, 在查找元素时, 只需查找某一边子树(大于则为右子树, 小于则为左子树). 其时间复杂度为 O(h) (h为二叉搜索树的高度)</p><p>二叉搜索树的查找:</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">,</span> val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>
    cur <span class="token operator">:=</span> root 
    <span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> val <span class="token operator">==</span> cur<span class="token punctuation">.</span>Val <span class="token punctuation">{</span>
            <span class="token keyword">break</span> 
        <span class="token punctuation">}</span>
        <span class="token comment">// 左子树</span>
        <span class="token keyword">if</span> val <span class="token operator">&lt;</span> cur<span class="token punctuation">.</span>Val <span class="token punctuation">{</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Left
        <span class="token punctuation">}</span>
        <span class="token comment">// 右子树</span>
        <span class="token keyword">if</span> val <span class="token operator">&gt;</span> cur<span class="token punctuation">.</span>Val <span class="token punctuation">{</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Right
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> cur
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8-3-1-问题52-展平二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_8-3-1-问题52-展平二叉搜索树" aria-hidden="true">#</a> 8.3.1 问题52: 展平二叉搜索树</h2>`,5),y={href:"https://leetcode.cn/problems/NYBBNL/",target:"_blank",rel:"noopener noreferrer"},_=t(`<blockquote><p>给你一棵二叉搜索树，请 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p><p><strong>示例 1：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [5,1,7]
输出：[1,null,5,null,7]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点数的取值范围是 <code>[1, 100]</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><h3 id="_8-3-1-1-分析-题解" tabindex="-1"><a class="header-anchor" href="#_8-3-1-1-分析-题解" aria-hidden="true">#</a> 8.3.1.1 分析&amp;题解</h3><p>二叉搜索树的最底层的最左节点一定是最小节点, 那么这个节点一定是展开后的根节点.</p><p>因为要断开左节点, 然后连接至根节点的右节点; 顺序为左中右, 所以使用中序遍历.</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">increasingBST</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>
    st <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment">// stack</span>
    cur <span class="token operator">:=</span> root                   <span class="token comment">// current node</span>
    <span class="token keyword">var</span> prev <span class="token operator">*</span>TreeNode            <span class="token comment">// previous node</span>
    <span class="token keyword">var</span> newRoot <span class="token operator">*</span>TreeNode         <span class="token comment">// new tree root</span>

    <span class="token comment">// inorder dsf</span>
    <span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> <span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        <span class="token comment">// left </span>
        <span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            st <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> cur<span class="token punctuation">)</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Left
        <span class="token punctuation">}</span>
        <span class="token comment">// mid</span>
        cur <span class="token operator">=</span> st<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        st <span class="token operator">=</span> st<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>

        <span class="token comment">// 连接到前一节点</span>
        <span class="token keyword">if</span> prev <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            prev<span class="token punctuation">.</span>Right <span class="token operator">=</span> cur
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 新树的根节点</span>
            newRoot <span class="token operator">=</span> cur
        <span class="token punctuation">}</span>

        <span class="token comment">// right</span>
        prev <span class="token operator">=</span> cur
        <span class="token comment">// 断开左子树</span>
        cur<span class="token punctuation">.</span>Left <span class="token operator">=</span> <span class="token boolean">nil</span>
        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Right
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> newRoot
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8-3-2-问题53-二叉搜索树的下一个节点" tabindex="-1"><a class="header-anchor" href="#_8-3-2-问题53-二叉搜索树的下一个节点" aria-hidden="true">#</a> 8.3.2 问题53: 二叉搜索树的下一个节点</h2>`,6),w={href:"https://leetcode.cn/problems/P5rCT8/",target:"_blank",rel:"noopener noreferrer"},N=t(`<blockquote><p>给定一棵二叉搜索树和其中的一个节点 <code>p</code> ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 <code>null</code> 。</p><p>节点 <code>p</code> 的后继是值比 <code>p.val</code> 大的节点中键值最小的节点，即按中序遍历的顺序节点 <code>p</code> 的下一个节点。</p><p><strong>示例 1：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2019/01/23/285_example_1.PNG" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [2,1,3], p = 1
输出：2
解释：这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2019/01/23/285_example_2.PNG" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [5,3,6,2,4,null,null,1], p = 6
输出：null
解释：因为给出的节点没有中序后继，所以答案就返回 null 了。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 10^4]</code> 内。</li><li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li><li>树中各节点的值均保证唯一。</li></ul></blockquote><h3 id="_8-3-2-1-分析-题解" tabindex="-1"><a class="header-anchor" href="#_8-3-2-1-分析-题解" aria-hidden="true">#</a> 8.3.2.1 分析&amp;题解</h3><p>中序遍历二叉搜索树的结果一定是递增序列, 那么<code>p</code>的中序后继一定是大于<code>p</code>的节点中的最小的那个.</p><p>流程:</p><ol><li>遍历, 比较当前节点<code>cur</code>和<code>p</code><ol><li><code>p &gt; cur</code> , 则进入右子树查找</li><li><code>p &lt; cur</code>, 记录当前节点, 进入左子树查找</li></ol></li><li>最后一个记录的节点就是<code>p</code>的中序后继</li></ol><p>时间复杂度: O(h), h为二叉搜索树的高度</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">inorderSuccessor</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">,</span> p <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>
    <span class="token keyword">var</span> res <span class="token operator">*</span>TreeNode
    cur <span class="token operator">:=</span> root <span class="token comment">// current node</span>
    <span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> cur<span class="token punctuation">.</span>Val <span class="token operator">&gt;</span> p<span class="token punctuation">.</span>Val <span class="token punctuation">{</span>
            <span class="token comment">// left tree</span>
            <span class="token comment">// record result</span>
            res <span class="token operator">=</span> cur
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Left
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// right tree</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Right
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8-3-3-问题54-所有大于等于节点的值之和" tabindex="-1"><a class="header-anchor" href="#_8-3-3-问题54-所有大于等于节点的值之和" aria-hidden="true">#</a> 8.3.3 问题54: 所有大于等于节点的值之和</h2>`,8),T={href:"https://leetcode.cn/problems/w6cpku/",target:"_blank",rel:"noopener noreferrer"},z=t(`<blockquote><p>定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="img" loading="lazy"></strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [0,null,1]
输出：[1,null,1]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [1,0,2]
输出：[3,3,2]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 4：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [3,2,4,1]
输出：[7,9,4,10]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中的节点数介于 <code>0</code> 和 <code>10^4</code> 之间。</li><li>每个节点的值介于 <code>-10^4</code> 和 <code>10^4</code> 之间。</li><li>树中的所有值 <strong>互不相同</strong> 。</li><li>给定的树为二叉搜索树。</li></ul></blockquote><h3 id="_8-3-3-1-分析-题解" tabindex="-1"><a class="header-anchor" href="#_8-3-3-1-分析-题解" aria-hidden="true">#</a> 8.3.3.1 分析&amp;题解</h3>`,2),S=s("p",null,[n("若从大到小来遍历, 那么节点序列可看作"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"N"),s("mn",null,"1")]),s("mo",{separator:"true"},","),s("mi",{mathvariant:"normal"},"."),s("mi",{mathvariant:"normal"},"."),s("mi",{mathvariant:"normal"},"."),s("mo",{separator:"true"},","),s("msub",null,[s("mi",null,"N"),s("mrow",null,[s("mi",null,"i"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",{separator:"true"},","),s("msub",null,[s("mi",null,"N"),s("mi",null,"i")]),s("mo",{separator:"true"},","),s("mi",null,"N"),s("mrow",null,[s("mi",null,"i"),s("mo",null,"+"),s("mn",null,"1")]),s("mo",{separator:"true"},","),s("mi",{mathvariant:"normal"},"."),s("mi",{mathvariant:"normal"},"."),s("mi",{mathvariant:"normal"},"."),s("mo",{separator:"true"},","),s("msub",null,[s("mi",null,"N"),s("mi",null,"n")])]),s("annotation",{encoding:"application/x-tex"},"N_1,...,N_{i-1},N_i,N{i+1}, ..., N_n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8917em","vertical-align":"-0.2083em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},"..."),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"i"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2083em"}},[s("span")])])])])]),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"1")]),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},"..."),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"n")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" , ("),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"N"),s("mi",null,"i")]),s("mo",null,">"),s("msub",null,[s("mi",null,"N"),s("mrow",null,[s("mi",null,"i"),s("mo",null,"+"),s("mn",null,"1")])])]),s("annotation",{encoding:"application/x-tex"},"N_i>N_{i+1}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},">"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8917em","vertical-align":"-0.2083em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"i"),s("span",{class:"mbin mtight"},"+"),s("span",{class:"mord mtight"},"1")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2083em"}},[s("span")])])])])])])])]),n("). 对节点"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"N"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"N_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(", 比它大的节点已经遍历过, 那么此时"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"N"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"N_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" 的新值就是之前的节点和"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"N"),s("mn",null,"1")]),s("mo",null,"+"),s("msub",null,[s("mi",null,"N"),s("mn",null,"2")]),s("mo",null,"+"),s("mi",{mathvariant:"normal"},"."),s("mi",{mathvariant:"normal"},"."),s("mi",{mathvariant:"normal"},"."),s("mo",null,"+"),s("msub",null,[s("mi",null,"N"),s("mrow",null,[s("mi",null,"i"),s("mo",null,"−"),s("mn",null,"1")])])]),s("annotation",{encoding:"application/x-tex"},"N_1+N_2+...+N_{i-1}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"..."),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8917em","vertical-align":"-0.2083em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"i"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2083em"}},[s("span")])])])])])])])]),n(".")],-1),q=t(`<p>中序遍历二叉搜索树, 结果是递增的; 将中序遍历的顺序颠倒, 先遍历右子树, 那么结果就是递减的.</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">convertBST</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>
    st <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// stack</span>
    cur <span class="token operator">:=</span> root
    sum <span class="token operator">:=</span> <span class="token number">0</span>

    <span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> <span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        <span class="token comment">// right tree</span>
        <span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            st <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> cur<span class="token punctuation">)</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Right
        <span class="token punctuation">}</span>

        <span class="token comment">// sum</span>
        cur <span class="token operator">=</span> st<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        st <span class="token operator">=</span> st<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        sum <span class="token operator">+=</span> cur<span class="token punctuation">.</span>Val
        cur<span class="token punctuation">.</span>Val <span class="token operator">=</span> sum

        <span class="token comment">// left tree</span>
        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Left
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8-3-4-问题55-二叉搜索树迭代器" tabindex="-1"><a class="header-anchor" href="#_8-3-4-问题55-二叉搜索树迭代器" aria-hidden="true">#</a> 8.3.4 问题55: 二叉搜索树迭代器</h2>`,3),B={href:"https://leetcode.cn/problems/kTOapQ/",target:"_blank",rel:"noopener noreferrer"},I=t(`<blockquote><p>实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p><ul><li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li><li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li><li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li></ul><p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p><p>可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p><p><strong>示例：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入
inputs = [&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]
inputs = [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
输出
[null, 3, 7, true, 9, true, 15, true, 20, false]

解释
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // 返回 3
bSTIterator.next();    // 返回 7
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 9
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 15
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 20
bSTIterator.hasNext(); // 返回 False
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 10^5]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 10^6</code></li><li>最多调用 <code>10^5</code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li></ul><p><strong>进阶：</strong></p><ul><li>你可以设计一个满足下述条件的解决方案吗？<code>next()</code> 和 <code>hasNext()</code> 操作均摊时间复杂度为 <code>O(1)</code> ，并使用 <code>O(h)</code> 内存。其中 <code>h</code> 是树的高度。</li></ul></blockquote><h3 id="_8-3-4-分析-题解" tabindex="-1"><a class="header-anchor" href="#_8-3-4-分析-题解" aria-hidden="true">#</a> 8.3.4 分析&amp;题解</h3><p>根据二叉树的中序遍历的迭代代码可知, 遍历的条件就是是否存在下一节点, 即<code>hasNext</code>. 而获取下一节点的代码就是遍历循环的循环体.</p><p>SC: O(h), h为二叉树高度, 维护一个栈</p><p>TC: 平均为O(1), 调用n次<code>next</code> 遍历完二叉树</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> BSTIterator <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	cur <span class="token operator">*</span>TreeNode   <span class="token comment">// curren node</span>
	st  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode <span class="token comment">// stack</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">Constructor</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> BSTIterator <span class="token punctuation">{</span>
	<span class="token keyword">return</span> BSTIterator<span class="token punctuation">{</span>
		cur<span class="token punctuation">:</span> root<span class="token punctuation">,</span>
		st<span class="token punctuation">:</span>  <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>bi <span class="token operator">*</span>BSTIterator<span class="token punctuation">)</span> <span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token comment">// left tree</span>
	<span class="token keyword">for</span> bi<span class="token punctuation">.</span>cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		bi<span class="token punctuation">.</span>st <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>bi<span class="token punctuation">.</span>st<span class="token punctuation">,</span> bi<span class="token punctuation">.</span>cur<span class="token punctuation">)</span>
		bi<span class="token punctuation">.</span>cur <span class="token operator">=</span> bi<span class="token punctuation">.</span>cur<span class="token punctuation">.</span>Left
	<span class="token punctuation">}</span>

	bi<span class="token punctuation">.</span>cur <span class="token operator">=</span> bi<span class="token punctuation">.</span>st<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>bi<span class="token punctuation">.</span>st<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
	bi<span class="token punctuation">.</span>st <span class="token operator">=</span> bi<span class="token punctuation">.</span>st<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>bi<span class="token punctuation">.</span>st<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
	val <span class="token operator">:=</span> bi<span class="token punctuation">.</span>cur<span class="token punctuation">.</span>Val

	<span class="token comment">// right tree</span>
	bi<span class="token punctuation">.</span>cur <span class="token operator">=</span> bi<span class="token punctuation">.</span>cur<span class="token punctuation">.</span>Right

	<span class="token keyword">return</span> val
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>bi <span class="token operator">*</span>BSTIterator<span class="token punctuation">)</span> <span class="token function">HasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> bi<span class="token punctuation">.</span>cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> <span class="token function">len</span><span class="token punctuation">(</span>bi<span class="token punctuation">.</span>st<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8-3-5-问题56-二叉搜索树两个节点的值之和" tabindex="-1"><a class="header-anchor" href="#_8-3-5-问题56-二叉搜索树两个节点的值之和" aria-hidden="true">#</a> 8.3.5 问题56: 二叉搜索树两个节点的值之和</h2>`,7),L={href:"https://leetcode.cn/problems/opLdQZ/",target:"_blank",rel:"noopener noreferrer"},R=t(`<blockquote><p>给定一个二叉搜索树的 <strong>根节点</strong> <code>root</code> 和一个整数 <code>k</code> , 请判断该二叉搜索树中是否存在两个节点它们的值之和等于 <code>k</code> 。假设二叉搜索树中节点的值均唯一。</p><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: root = [8,6,10,5,7,9,11], k = 12
输出: true
解释: 节点 5 和节点 7 之和等于 12
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: root = [8,6,10,5,7,9,11], k = 22
输出: false
解释: 不存在两个节点值之和为 22 的节点
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1, 10^4]</code>.</li><li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li><li><code>root</code> 为二叉搜索树</li><li><code>-10^5 &lt;= k &lt;= 10^5</code></li></ul></blockquote><h3 id="_8-3-5-1-分析-题解" tabindex="-1"><a class="header-anchor" href="#_8-3-5-1-分析-题解" aria-hidden="true">#</a> 8.3.5.1 分析&amp;题解</h3><h4 id="哈希表" tabindex="-1"><a class="header-anchor" href="#哈希表" aria-hidden="true">#</a> 哈希表</h4><p>中序遍历+哈希表</p><p>TC: O(n) SC: O(n)</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">findTarget</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">,</span> k <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
    m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

    st <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    cur <span class="token operator">:=</span> root 
    <span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> <span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        <span class="token comment">// left </span>
        <span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            st <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> cur<span class="token punctuation">)</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Left
        <span class="token punctuation">}</span>

        <span class="token comment">// node</span>
        cur <span class="token operator">=</span> st<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        st <span class="token operator">=</span> st<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span>  m<span class="token punctuation">[</span>k<span class="token operator">-</span>cur<span class="token punctuation">.</span>Val<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
            <span class="token keyword">return</span> v
        <span class="token punctuation">}</span> 
        m<span class="token punctuation">[</span>cur<span class="token punctuation">.</span>Val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>

        <span class="token comment">// right</span>
        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Right
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="双指针" tabindex="-1"><a class="header-anchor" href="#双指针" aria-hidden="true">#</a> 双指针</h4><p>由于二叉搜索树是有序的, 那么个可以创建两个相反方向的迭代器, 相当于相反的双指针.</p><p>问题就转换成了有序数组的两数之和的双指针解法.</p><p>TC: O(n), SC: O(h), h为二叉树高度, 因为高度远小于节点数, 所以空间复杂度小于O(n)</p><p>// TODO: 2023-09-12</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code></code></pre><div class="line-numbers" aria-hidden="true"></div></div><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2>`,13),C={href:"https://book.douban.com/subject/35543447/",target:"_blank",rel:"noopener noreferrer"},M={href:"https://en.wikipedia.org/wiki/Binary_search_tree",target:"_blank",rel:"noopener noreferrer"};function O(V,j){const a=i("ExternalLinkIcon");return p(),o("div",null,[r,u,s("blockquote",null,[s("p",null,[n("In "),s("a",d,[n("computer science"),e(a)]),n(", a "),m,n(" ("),v,n("), also called an "),k,n(" or "),g,n(", is a "),s("a",h,[n("rooted"),e(a)]),n(),s("a",b,[n("binary tree"),e(a)]),n(),s("a",f,[n("data structure"),e(a)]),n(" with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.")])]),x,s("p",null,[s("a",y,[n("LCR 052. 递增顺序搜索树"),e(a)])]),_,s("p",null,[s("a",w,[n("LCR 053. 二叉搜索树中的中序后继"),e(a)])]),N,s("p",null,[s("a",T,[n("LCR 054. 把二叉搜索树转换为累加树"),e(a)])]),z,S,q,s("p",null,[s("a",B,[n("LCR 055. 二叉搜索树迭代器"),e(a)])]),I,s("p",null,[s("a",L,[n("LCR 056. 两数之和 IV - 输入二叉搜索树"),e(a)])]),R,s("ol",null,[s("li",null,[s("a",C,[n("剑指Offer（专项突破版）"),e(a)])]),s("li",null,[s("a",M,[n("Binary Search Tree"),e(a)]),n(" wiki")])])])}const P=l(c,[["render",O],["__file","08.3.html.vue"]]);export{P as default};
