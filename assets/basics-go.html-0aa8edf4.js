import{_ as t,Z as i,$ as l,a0 as e,a1 as n,a2 as s,a3 as o,H as p}from"./framework-dee406ed.js";const r={},c=o(`<h1 id="protocol-buffer-basics-go" tabindex="-1"><a class="header-anchor" href="#protocol-buffer-basics-go" aria-hidden="true">#</a> Protocol Buffer Basics: Go</h1><p>This tutorial provides a basic Go programmer’s introduction to working with protocol buffers, using the <code>proto3</code> version of the protocol buffers language. By walking through creating a simple example application, it shows you how to</p><ul><li>Define message formats in a <code>.proto</code> file</li><li>Use the protocol buffer compiler</li><li>Use the Go protocol buffer API to write and read message</li></ul><h2 id="_1-why-use-protocol-buffers" tabindex="-1"><a class="header-anchor" href="#_1-why-use-protocol-buffers" aria-hidden="true">#</a> 1. Why use protocol buffers</h2><p>The example we are going to use is a very simple “address book” application that can read and write people’s contact details to and from a file. Each person in the address book has a name, an ID, an email address, and a contact phone number.</p><p>How do you serialize and retrieve structured data like this? There are a few ways to solve this problem:</p><ul><li>Use <code>gobs</code> to serialize the Go data structures. This is good solution in a Go-specific environment, but it doesn’t work well if you need to share data with applications written for other platforms</li><li>You can invent an ad-hoc way to encode the data items into a single string - such as encoding 4 ints as “12:3:-23:67”. This is a simple and flexible approach, although it does require writing one-off encoding and parsing code, and the parsing impose a small run-time cost. This works best for encoding very simple data</li><li>Serialize the data to XML. This approach can be very attractive since XML is (sort of) human readable and there are binding libraries for lots of languages. This can be a good choice if you wan to share data with other applications/projects. However, XML is notoriously space intensive, and encoding/decoding it can impose a huge performance penalty on applications. Also, navigating an XML DOM tree is considerably more complicated than navigating simple fields in a class normally would be</li></ul><p>Protocol buffers are the flexible, efficient, automated solution to solve exactly this problem. With protocol buffers, you write a <code>.proto</code> description of the data structure you wish to store. From that, the protocol buffer compiler creates a class that implements automatic encoding and parsing of the protocol buffer data with an efficient binary format. The generated class provides getters and setters for the fields that make up a protocol buffer and takes care of the details of reading and writing the protocol buffer as a unit. Importantly, the protocol buffer format supports the idea of extending the format over time in such a way that the code still read data encoded with the old format.</p><h2 id="_2-defining-your-protocol-format" tabindex="-1"><a class="header-anchor" href="#_2-defining-your-protocol-format" aria-hidden="true">#</a> 2. Defining your protocol format</h2><p>To create your address book application, you will need to start with a <code>.proto</code> file. The definitions in a <code>.proto</code> file are simple: you add a <em>message</em> for each data structure you want to serialize, the specify a name and a type for each field in the message. In our example, the <code>.proto</code> file that defines the message is <code>addressbook.proto</code>.</p><p>The <code>.proto</code> file starts with a package declaration, which helps to prevent naming conflicts between different projects.</p><div class="language-protobuf line-numbers-mode" data-ext="protobuf"><pre class="language-protobuf"><code><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">&quot;proto3&quot;</span>
<span class="token keyword">package</span> tutorial

<span class="token keyword">import</span> <span class="token string">&quot;google/protobuf/timestamp.proto&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>go_package</code> option defines the import path of the package which will contain all the generated code for this file. The Go package name will be the last path component of the import path. For example, our example will use a package name of “tutorialpb”.</p><div class="language-protobuf line-numbers-mode" data-ext="protobuf"><pre class="language-protobuf"><code><span class="token keyword">option</span> go_pacakge <span class="token operator">=</span> <span class="token string">&quot;protobuffers&quot;</span> <span class="token comment">// 这里将生成的 go 文件和 proto 文件放在同一目录下 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Next, you have your message definitions. A message is just an aggregate containing a set of typed fields. Many standard simple data types are available as field types, including <code>bool</code>,<code>int32</code>, <code>double</code>, and <code>string</code>. You can also add further structure to your messages by using other message types as field types.</p><div class="language-protobuf line-numbers-mode" data-ext="protobuf"><pre class="language-protobuf"><code><span class="token keyword">message</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// Unique ID number for this person</span>
  <span class="token builtin">string</span> email <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

  <span class="token keyword">enum</span> <span class="token class-name">PhoneType</span> <span class="token punctuation">{</span>
    MOBILE <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    HOME <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    WORK <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">message</span> <span class="token class-name">PhoneNumber</span> <span class="token punctuation">{</span>
    <span class="token builtin">string</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token positional-class-name class-name">PhoneType</span> type <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">repeated</span> <span class="token positional-class-name class-name">PhoneNumber</span> phones <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
  <span class="token positional-class-name class-name">google<span class="token punctuation">.</span>protobuf<span class="token punctuation">.</span>Timestamp</span> last_updated <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Our address book file is just one of these</span>
<span class="token keyword">message</span> <span class="token class-name">AddressBook</span> <span class="token punctuation">{</span>
  <span class="token keyword">repeated</span> <span class="token positional-class-name class-name">Person</span> people <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the above example, the <code>Person</code> message contains <code>PhoneNumber</code> messages, while the <code>AddressBook</code> message contains <code>Person</code> messages. You can even define message types nested inside other messages - as you can see, the <code>PhoneNumber</code> type is defined inside <code>Person</code>. You can also define <code>enum</code> types if you want one of your fields to have one of a predefined list of values - here you want to specify that a phone number can be one of <code>MOBILE</code>, <code>HOME</code>, or <code>WORK</code>.</p><p>The “=1”, “=2” markers on each element identify the unique “tag” that field uses in the binary encoding. Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used optional elements. Each element in a repeated field requires re-encoding the tag number, so repeated fields are particularly good candidates for the optimization.</p><p>If a field value is not set, a default value is used: zero for numeric types, the empty string for strings, false for bools. For embedded messages, the default value is always the “default instance” or “prototype” of the message, which has none of its fields set. Calling the accessor to get the value of a field which has not been explicitly set always returns that field’s default value.</p><p>If a field is <code>repeated</code>, the field may be repeated any number of times (including zero). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays.</p><p>Do not go looking for facilities similar to class inheritance, though - protocol buffers don’t do that.</p><h2 id="_3-compiling-your-protocol-buffers" tabindex="-1"><a class="header-anchor" href="#_3-compiling-your-protocol-buffers" aria-hidden="true">#</a> 3. Compiling your protocol buffers</h2><p>Now that you have a <code>.proto</code>, the next thing you need to do is generate the classes you will need to read and write <code>AddressBook</code> (and hence <code>Person</code> and <code>PhoneNumber</code>) messages. To do this, you need to run the protocol buffer compiler <code>protoc</code> on your <code>.proto</code>:</p>`,23),d={href:"https://developers.google.com/protocol-buffers/docs/downloads",target:"_blank",rel:"noopener noreferrer"},u=e("li",null,[e("p",null,"Run the following command to install the Go protocol buffers plugin:")],-1),h=o(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>go <span class="token function">install</span> google.golang.org/protobuf/cmd/protoc-gen-go@latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>The compiler plugin <code>protoc-gen-go</code> will be installed in <code>$GIBIN</code>, defaulting to <code>$GOPATH/bin</code>. It must be in your <code>$PATH</code> for the protocol compiler <code>protoc</code> to find it.</p><ol start="3"><li><p>Now run the compiler, specifying the source directory (where your application’s source code lives - the current directory is used if you don’t provide a value), the destination directory (where you want the generated code to go; often the same as <code>$SRC_DIR</code>), and the path to you <code>.proto</code>. In this case, you would invoke:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>protoc <span class="token parameter variable">-I</span><span class="token operator">=</span><span class="token variable">$SRC_DIR</span> <span class="token parameter variable">--go_out</span><span class="token operator">=</span><span class="token variable">$DST_DIR</span> <span class="token variable">$SRC_DIR</span>/addressbook.proto
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Because you want Go code, you use the <code>--go_out</code> option - similar options are provided for other supported languages.</p></li></ol><p>生成 code 之后需要安装 <code>google.golang.org/protobuf/proto</code> 依赖</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>go get <span class="token parameter variable">-u</span> google.golang.org/protobuf/proto
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_4-the-protocol-buffer-api" tabindex="-1"><a class="header-anchor" href="#_4-the-protocol-buffer-api" aria-hidden="true">#</a> 4. The Protocol Buffer API</h2><p>Generating <code>addressbook.pb.go</code> gives you the following useful types:</p><ul><li>An <code>AddressBook</code> structure with a <code>People</code> field</li><li>A <code>Person</code> structure with fields for <code>Name</code>, <code>Id</code>, <code>Email</code>, and <code>Phones</code></li><li>A <code>Person_PhoneNumber</code> structure, with fields for <code>Number</code> and <code>Type</code></li><li>The type <code>Person_PhoneType</code> and a value defined for each value in the <code>Person.PhoneType</code> enum</li></ul><p>Here’s an example from the <code>list_people</code> command’s unit tests of how you might create an instance of Person:</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>p <span class="token operator">:=</span> pb<span class="token punctuation">.</span>Person<span class="token punctuation">{</span>
        Id<span class="token punctuation">:</span>    <span class="token number">1234</span><span class="token punctuation">,</span>
        Name<span class="token punctuation">:</span>  <span class="token string">&quot;John Doe&quot;</span><span class="token punctuation">,</span>
        Email<span class="token punctuation">:</span> <span class="token string">&quot;jdoe@example.com&quot;</span><span class="token punctuation">,</span>
        Phones<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>pb<span class="token punctuation">.</span>Person_PhoneNumber<span class="token punctuation">{</span>
                <span class="token punctuation">{</span>Number<span class="token punctuation">:</span> <span class="token string">&quot;555-4321&quot;</span><span class="token punctuation">,</span> Type<span class="token punctuation">:</span> pb<span class="token punctuation">.</span>Person_HOME<span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-writing-a-message" tabindex="-1"><a class="header-anchor" href="#_5-writing-a-message" aria-hidden="true">#</a> 5. Writing a Message</h2><p>The whole purpose of using protocol buffers is to serialize your data so that it can be parsed elsewhere. In Go, you use the <code>proto</code> library’s Marshal function to serialize your protocol buffer data. A pointer to a protocol buffer message’s <code>struct</code> implements the <code>proto.Message</code> interface. Calling <code>proto.Marshal</code> returns the protocol buffer, encoded in its wire format. For example, we use this function in the <code>add_person</code> command:</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>book <span class="token operator">:=</span> <span class="token operator">&amp;</span>pb<span class="token punctuation">.</span>AddressBook<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// ...</span>

<span class="token comment">// Write the new address book back to disk.</span>
out<span class="token punctuation">,</span> err <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Fatalln</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to encode address book:&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">WriteFile</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> out<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Fatalln</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to write address book:&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-reading-a-message" tabindex="-1"><a class="header-anchor" href="#_6-reading-a-message" aria-hidden="true">#</a> 6. Reading a Message</h2><p>To parse an encoded message, you use the <code>proto</code> library’s Unmarshal function. Calling this parses the data in <code>in</code> as a protocol buffer and places the result in <code>book</code>. So to parse the file in the <code>list_people</code> command, we use :</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// Read the existing address book.</span>
in<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>fname<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Fatalln</span><span class="token punctuation">(</span><span class="token string">&quot;Error reading file:&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
book <span class="token operator">:=</span> <span class="token operator">&amp;</span>pb<span class="token punctuation">.</span>AddressBook<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">if</span> err <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> book<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Fatalln</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to parse address book:&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7-extending-a-protocol-buffer" tabindex="-1"><a class="header-anchor" href="#_7-extending-a-protocol-buffer" aria-hidden="true">#</a> 7. Extending a Protocol Buffer</h2><p>Sooner or later after you release the code that uses your protocol buffer, you will undoubtedly want to “improve” the protocol buffer’s definition. If you want your new buffers to be backwards-compatible, and your old buffers to be forward-compatible - and you almost certainly do want this - then there are some rules you need to follow. In the new version of the protocol buffer:</p><ul><li>you <em>must</em> do not change the tag numbers of any existing fields</li><li>you <em>may</em> delete fields</li><li>you <em>may</em> add new fields but you must use fresh tag numbers (i.e. tag numbers that were never used in this protocol buffer, not even by deleted fields)</li></ul>`,19),m={href:"https://developers.google.com/protocol-buffers/docs/proto3#updating",target:"_blank",rel:"noopener noreferrer"},f=e("p",null,"If you follow these rules, old code will happily read new messages and simply ignore any new fields. To the old code, singular fields that were deleted will simply have their default value, and deleted repeated fields will be empty. New code will also transparently read old messages.",-1),b=e("p",null,"However, keep in mind that new fields will not be present in old messages, so you will need to do something reasonable with the default value. A type-specific default value is used: for strings, the default value is empty string. For booleans, the default value is false. For numeric types, the default value is zero.",-1),k=e("h3",{id:"reference",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),n(" Reference")],-1),g={href:"https://developers.google.com/protocol-buffers/docs/gotutorial",target:"_blank",rel:"noopener noreferrer"};function v(y,w){const a=p("ExternalLinkIcon");return i(),l("div",null,[c,e("ol",null,[e("li",null,[e("p",null,[n("If you haven’t installed the compiler, "),e("a",d,[n("download the package"),s(a)]),n(" and follow the instructions in the README.")])]),u]),h,e("p",null,[n("(There are "),e("a",m,[n("some exceptions"),s(a)]),n(" to these rules, but they are rarely used.)")]),f,b,k,e("ol",null,[e("li",null,[e("a",g,[n("Basics: Go"),s(a)]),n(" protocol buffer tutorial")])])])}const x=t(r,[["render",v],["__file","basics-go.html.vue"]]);export{x as default};
