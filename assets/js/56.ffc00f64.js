(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{710:function(_,v,t){"use strict";t.r(v);var s=t(5),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[t("strong",[_._v("哈希表")]),_._v("是一种使用"),t("strong",[_._v("哈希函数")]),_._v("组织数据，以支持快速插入和搜索的数据结构。")]),_._v(" "),t("p",[_._v("哈希表有两种不同类型：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("哈希集合")]),_._v("： "),t("strong",[_._v("集合")]),_._v("数据结构的实现之一，用于存储非重复值")]),_._v(" "),t("li",[t("strong",[_._v("哈希映射")]),_._v("： "),t("strong",[_._v("映射")]),_._v("数据结构的实现之一，用于存储 K, V 键值对")])]),_._v(" "),t("h2",{attrs:{id:"_1-哈希表原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-哈希表原理"}},[_._v("#")]),_._v(" 1. 哈希表原理")]),_._v(" "),t("p",[_._v("哈希表的关键思想是"),t("strong",[_._v("将键映射到存储桶")]),_._v("：")]),_._v(" "),t("ul",[t("li",[_._v("插入新键时，哈希函数决定该键应该分配到哪个桶里，并将该键存储在相应桶中。")]),_._v(" "),t("li",[_._v("搜索一个键时，哈希表将使用相同的哈希函数查找对应的桶，并只在特定的桶中进行搜索。")])]),_._v(" "),t("p",[_._v("例如，将 "),t("code",[_._v("H(k) = k mod 5")]),_._v(" 作为哈希函数：")]),_._v(" "),t("ul",[t("li",[_._v("插入：通过哈希函数解析键，将其映射到对应的桶中")]),_._v(" "),t("li",[_._v("搜索：通过相同的哈希函数解析键，并在对应的桶中搜索\n"),t("ul",[t("li",[_._v("若搜索 1987，则在桶 2 中进行搜索可以找到")]),_._v(" "),t("li",[_._v("若搜索 23，则在桶 3 中寻找，发现不在哈希表中")])])])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/09/06/screen-shot-2018-02-19-at-183537.png",alt:"img"}})]),_._v(" "),t("h2",{attrs:{id:"_2-设计哈希表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-设计哈希表"}},[_._v("#")]),_._v(" 2. 设计哈希表")]),_._v(" "),t("h3",{attrs:{id:"_2-1-哈希函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-哈希函数"}},[_._v("#")]),_._v(" 2.1 哈希函数")]),_._v(" "),t("p",[_._v("哈希函数是哈希表最重要的组件，用于将键映射到特定的桶中。哈希函数将取决于"),t("strong",[_._v("键值的范围")]),_._v("和"),t("strong",[_._v("桶的数量")]),_._v("。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/05/04/screen-shot-2018-05-04-at-145454.png",alt:"img"}})]),_._v(" "),t("p",[_._v("哈希函数设计是一个开放问题，其思想是尽可能将键分配到桶中，理想情况下，完美的哈希函数是将键和桶之间进行一对一映射。")]),_._v(" "),t("h3",{attrs:{id:"_2-2-哈希冲突"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-哈希冲突"}},[_._v("#")]),_._v(" 2.2 哈希冲突")]),_._v(" "),t("p",[_._v("在大多数情况下，相同的键映射到相同的桶中，即哈希冲突，是不可避免的。此时需要一个解决冲突的算法，来解决以下问题：")]),_._v(" "),t("ul",[t("li",[_._v("如何组织相同桶中的值")]),_._v(" "),t("li",[_._v("如何解决一个桶中的值过多的问题")]),_._v(" "),t("li",[_._v("如何在特定的桶中搜索目标值")])]),_._v(" "),t("p",[_._v("根据哈希函数，这些与"),t("strong",[_._v("桶的容量")]),_._v("和"),t("strong",[_._v("键的数量")]),_._v("有关。假设桶中存储了 N 个键，当 N 为常数且很小时，简单使用数组即可。若 N 是可变的或者非常大，此时需要其他数据结构如"),t("strong",[_._v("高度平衡二叉树")]),_._v("来代替。")]),_._v(" "),t("h2",{attrs:{id:"_3-复杂度分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-复杂度分析"}},[_._v("#")]),_._v(" 3. 复杂度分析")]),_._v(" "),t("p",[_._v("若总共有 M 个键，哈希表很容易达到 "),t("em",[_._v("O(M)")]),_._v(" 的空间复杂度。")]),_._v(" "),t("p",[_._v("但是时间复杂度和哈希表的设计有关，若使用"),t("strong",[_._v("数组")]),_._v("来将值存储到一个桶中，理想情况下，桶的大小足够小时，可以看做常数，那么插入和搜索的时间复杂度为 "),t("em",[_._v("O(1)")]),_._v("。但是在最坏的情况下，桶的最大值为 "),t("code",[_._v("N")]),_._v("，插入时间复杂度为 "),t("em",[_._v("O(1)")]),_._v("，搜索时间复杂度为 "),t("em",[_._v("O(N)")]),_._v("。")]),_._v(" "),t("p",[_._v("一般内置哈希表的典型设计是：")]),_._v(" "),t("ul",[t("li",[_._v("键值可以是任何 "),t("strong",[_._v("可哈希化的")]),_._v(" 类型，且具有 "),t("strong",[_._v("哈希码")]),_._v("，将用于映射函数以获取存储区索引。")]),_._v(" "),t("li",[_._v("每个桶中包含一个 "),t("strong",[_._v("数组")]),_._v("，用于在初始时将所有值存储在同一个桶中")]),_._v(" "),t("li",[_._v("如果在同一个桶中有太多值，这些值将会保存在 "),t("strong",[_._v("高度平衡二叉搜索树")]),_._v("中，插入和搜多的平均时间复杂度为 "),t("em",[_._v("O(1)")]),_._v("，而最坏情况下，时间复杂度为 "),t("em",[_._v("O(logN)")])])]),_._v(" "),t("h2",{attrs:{id:"reference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[_._v("#")]),_._v(" Reference")]),_._v(" "),t("ol",[t("li",[_._v("[哈希表] (https://leetcode-cn.com/leetbook/read/hash-table/x6sast/) leetbook")])])])}),[],!1,null,null,null);v.default=a.exports}}]);