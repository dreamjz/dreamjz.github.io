(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{659:function(_,t,e){_.exports=e.p+"assets/img/redis-cache.0ed97400.png"},784:function(_,t,e){"use strict";e.r(t);var s=e(5),v=Object(s.a)({},(function(){var _=this,t=_.$createElement,s=_._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h2",{attrs:{id:"_1-数据结构及使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据结构及使用场景"}},[_._v("#")]),_._v(" 1. 数据结构及使用场景")]),_._v(" "),s("ul",[s("li",[_._v("String 字符串\nKey 都为字符串类型，Set key val 使用的是字符串；")]),_._v(" "),s("li",[_._v("Hash 哈希\n键值对结构；")]),_._v(" "),s("li",[_._v("List 列表（双向链表）\n存储多个有序的字符串；")]),_._v(" "),s("li",[_._v("Set 集合\n集合中不允许有重复元素，元素是无序的。可以进行相关的集合计算（交并补等）；")]),_._v(" "),s("li",[_._v("Zset （Sorted Set，有序集合）\n采用跳表实现，相较于 Set  多了 Score 从，元素可按照 Score 进行排列；")])]),_._v(" "),s("h2",{attrs:{id:"_2-持久化方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-持久化方式"}},[_._v("#")]),_._v(" 2. 持久化方式")]),_._v(" "),s("ol",[s("li",[_._v("RDB ：快照形式将内存中的数据保存到一个 dump 文件中，定时保存；\n当 Redis 需要持久化时，会 fork 一个子进程，子进程将数据写入磁盘上的临时 RDB 文件中。当子进程写完后，将原来的 RDB 替换掉。")]),_._v(" "),s("li",[_._v("AOF： 把所有的修改命令存到一个文件中；\n使用 AOF 做持久化，每一个写命令都将追加到 "),s("code",[_._v("appendonly.aof")]),_._v(" 文件中。AOF 的默认策略是每秒中同步一次。\n缺点：AOF 文件体积大于 RDB，且相对较慢；")])]),_._v(" "),s("p",[_._v("Redis "),s("strong",[_._v("默认")]),_._v("使用 RDB 快照。")]),_._v(" "),s("h2",{attrs:{id:"_3-数据过期-和-缓存淘汰-策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-数据过期-和-缓存淘汰-策略"}},[_._v("#")]),_._v(" 3. 数据过期 和 缓存淘汰 策略")]),_._v(" "),s("h3",{attrs:{id:"数据过期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据过期"}},[_._v("#")]),_._v(" 数据过期")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("**定时过期：**每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。")])]),_._v(" "),s("li",[s("p",[_._v("**惰性过期：**只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。")])]),_._v(" "),s("li",[s("p",[_._v("**定期过期：**每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。(expires字典会保存所有设置了过期时间的key的过期时间数据，其中key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)")])])]),_._v(" "),s("p",[_._v("Redis同时使用了惰性过期和定期过期两种过期策略。但是Redis定期删除是随机抽取机制，不可能扫描删除掉所有的过期Key。因此需要内存淘汰机制。")]),_._v(" "),s("h3",{attrs:{id:"缓存淘汰"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存淘汰"}},[_._v("#")]),_._v(" 缓存淘汰")]),_._v(" "),s("p",[s("img",{attrs:{src:e(659),alt:"Redis缓存淘汰策略.png"}})]),_._v(" "),s("h2",{attrs:{id:"_4-单线程-redis-为什么快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-单线程-redis-为什么快"}},[_._v("#")]),_._v(" 4. 单线程 Redis 为什么快")]),_._v(" "),s("ul",[s("li",[_._v("纯内存操作")]),_._v(" "),s("li",[_._v("单线程操作，避免频繁的上下文切换")]),_._v(" "),s("li",[_._v("高效的数据结构")]),_._v(" "),s("li",[_._v("采用非阻塞 I/O 多路复用机制")])]),_._v(" "),s("h2",{attrs:{id:"_5-如何解决缓存雪崩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-如何解决缓存雪崩"}},[_._v("#")]),_._v(" 5. 如何解决缓存雪崩")]),_._v(" "),s("ul",[s("li",[_._v("使用 Redis 高可用架构：使用 Redis 集群保证 Redis 服务不会挂掉")]),_._v(" "),s("li",[_._v("缓存时间不一致，给缓存失效时间加上一个随机值，避免集体失效")]),_._v(" "),s("li",[_._v("限流降级 策略")])]),_._v(" "),s("h2",{attrs:{id:"_6-如何解决缓存穿透"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-如何解决缓存穿透"}},[_._v("#")]),_._v(" 6. 如何解决缓存穿透")]),_._v(" "),s("ul",[s("li",[_._v("接口层做校验")]),_._v(" "),s("li",[_._v("存 NULL 值，缓存击穿加锁")]),_._v(" "),s("li",[_._v("布隆过滤器拦截：将所有可能的 Key 先映射到布隆过滤器中，查询时先判断是否存在布隆过滤器中，存在继续执行，不存在则返回；布隆过滤器中元素存在可能误判，元素不存在则一定不存在；")])]),_._v(" "),s("h2",{attrs:{id:"_7-主从-哨兵-集群"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-主从-哨兵-集群"}},[_._v("#")]),_._v(" 7. 主从 哨兵 集群")]),_._v(" "),s("ul",[s("li",[_._v("主从模式\n基于主从复制特性，主节点负责使用者的 IO 操作，从节点进行数据备份，并提供读操作；实现读写分离。\n主节点宕机，其他从节点不会竞争称为主节点，会丧失写能力；")]),_._v(" "),s("li",[_._v("哨兵模式\n相较于主从，多了竞选机制，从从节点中竞选出主节点；")]),_._v(" "),s("li",[_._v("集群模式\n集群是提供在多个 Redis 节点间共享数据的程序集，中Redis集群分为主节点和从节点。主节点用于处理槽,而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线的主节点继续处理命令请求。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);