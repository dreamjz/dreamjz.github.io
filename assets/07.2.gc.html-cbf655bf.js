import{_ as o,Z as r,$ as p,a0 as n,a2 as e,a1 as s,a3 as t,H as i}from"./framework-dee406ed.js";const c={},l=t(`<h2 id="_7-2-1-设计原理" tabindex="-1"><a class="header-anchor" href="#_7-2-1-设计原理" aria-hidden="true">#</a> 7.2.1 设计原理</h2><p>Golang 的内存管理组件：</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030304479.png" alt="mutator-allocator-collector" tabindex="0" loading="lazy"><figcaption>mutator-allocator-collector</figcaption></figure><p>如上图所示，用户程序（Mutator）会通过内存分配器（Allocator）在堆上申请内存，而垃圾收集器（Collector）负责回收堆上的内存空间，内存分配器和垃圾收集器共同管理着程序中的堆内存空间。</p><h3 id="标记清除" tabindex="-1"><a class="header-anchor" href="#标记清除" aria-hidden="true">#</a> 标记清除</h3><p>标记清除（Mark-Sweep）是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ol><li>标记阶段：从根对象出发查找并标记堆中所有存活的对象</li><li>清除阶段：遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表</li></ol><h4 id="标记-mark" tabindex="-1"><a class="header-anchor" href="#标记-mark" aria-hidden="true">#</a> 标记 Mark</h4><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030353922.png" alt="mark-sweep-mark-phase" tabindex="0" loading="lazy"><figcaption>mark-sweep-mark-phase</figcaption></figure><p>如图所示，内存空间中包含多个对象，从<strong>根对象</strong>出发依次遍历对象的子对象并将从根节点<strong>可达</strong>的对象都标记成存活状态，即 A、C 和 D 三个对象，剩余的 B、E 和 F 三个对象因为从根节点<strong>不可达</strong>，所以会被当做垃圾。</p><h4 id="清除-sweep" tabindex="-1"><a class="header-anchor" href="#清除-sweep" aria-hidden="true">#</a> 清除 Sweep</h4><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030356234.png" alt="mark-sweep-sweep-phase" tabindex="0" loading="lazy"><figcaption>mark-sweep-sweep-phase</figcaption></figure><p>标记阶段结束后会进入清除阶段，在该阶段中收集器会依次遍历堆中的所有对象，<strong>释放</strong>其中<strong>没有被标记</strong>的 B、E 和 F 三个对象并将新的空闲内存空间以链表的结构串联起来，方便内存分配器的使用。</p><p>标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的垃圾，整个过程需要标记对象的存活状态，用户程序在垃圾收集的过程中也不能执行，即暂停程序（Stop the world，STW）。</p><h3 id="三色标记" tabindex="-1"><a class="header-anchor" href="#三色标记" aria-hidden="true">#</a> 三色标记</h3><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030400664.png" alt="tri-color-objects" tabindex="0" loading="lazy"><figcaption>tri-color-objects</figcaption></figure><p>三色标记算法将程序中的对象分成黑色、白色和灰色三类：</p><ol><li>黑色对象：活跃的对象，包括： <ul><li>不存在任何引用外部指针的对象</li><li>从根对象可达的对象</li></ul></li><li>白色对象：潜在的垃圾，其内存可能会被垃圾收集器回收</li><li>灰色对象：活跃的对象，因为存在<strong>指向白色</strong>对象的<strong>外部指针</strong>，垃圾收集器会<strong>扫描</strong>这些对象的<strong>子对象</strong></li></ol><h4 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程" aria-hidden="true">#</a> 工作流程</h4><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030401561.png" alt="tri-color-mark-sweep" tabindex="0" loading="lazy"><figcaption>tri-color-mark-sweep</figcaption></figure><p>垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的<strong>根对象</strong>会被标记成<strong>灰色</strong>，垃圾收集器只会从<strong>灰色对象集合</strong>中取出对象开始<strong>扫描</strong>，当<strong>灰色集合</strong>中<strong>不存在</strong>任何对象时，标记阶段就会<strong>结束</strong>。</p><p>三色标记垃圾收集器工作步骤分为三步：</p><ol><li>从灰色对象的集合中选择一个灰色对象并将其标记成黑色</li><li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收</li><li>重复上述两个步骤直到对象图中不存在灰色对象</li></ol><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030404985.png" alt="tri-color-mark-sweep-after-mark-phase" tabindex="0" loading="lazy"><figcaption>tri-color-mark-sweep-after-mark-phase</figcaption></figure><p>因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是<strong>不可以并发</strong>或者<strong>增量</strong>执行的，它仍然<strong>需要 STW</strong>。如下图所示，若用户在标记过程中建立了从 A 对象到 D 对象的引用，但因程序中已经不存在灰色对象，所以 D 对象会被垃圾收集器<strong>错误</strong>地回收。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030407578.png" alt="tri-color-mark-sweep-and-mutator" tabindex="0" loading="lazy"><figcaption>tri-color-mark-sweep-and-mutator</figcaption></figure><p>本来<strong>不应该被回收</strong>的对象却<strong>被回收</strong>了，这在内存管理中是非常严重的错误，这种错误称为<strong>悬挂指针</strong>，即指针没有指向特定类型的合法对象，影响了内存的安全性，想要<strong>并发或者增量</strong>地<strong>标记</strong>对象还是需要使用<strong>屏障技术</strong>。</p><h4 id="屏障技术" tabindex="-1"><a class="header-anchor" href="#屏障技术" aria-hidden="true">#</a> 屏障技术</h4><p>内存屏障技术是一种屏障指令，可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束。</p><p>多数的现代处理器都会<strong>乱序</strong>执行指令以最大化性能，<strong>屏障技术</strong>能够保证内存操作的<strong>顺序性</strong>，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。</p><p>若在并发或者增量的标记算法中保证正确性，需要<strong>达成</strong>以下两种三色不变性（Tri-color invariant）中的<strong>一种</strong>：</p><ol><li>强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象</li><li>弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</li></ol><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030410973.png" alt="strong-weak-tricolor-invariant" tabindex="0" loading="lazy"><figcaption>strong-weak-tricolor-invariant</figcaption></figure><p>屏障技术可以分为：</p><ol><li>读屏障（Read barrier）</li><li>写屏障（Write barrier）</li></ol><p>因为<strong>读屏障</strong>需要在<strong>读操作</strong>中加入代码片段，对用户程序的<strong>性能影响</strong>很大，所以编程语言往往都会<strong>采用写屏障</strong>保证三色不变性。</p><h4 id="插入写屏障" tabindex="-1"><a class="header-anchor" href="#插入写屏障" aria-hidden="true">#</a> 插入写屏障</h4><p>由 Dijkstra 提出，通过如下所示的写屏障，用户程序和垃圾收集器可以在交替工作的情况下保证程序执行的正确性：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>writePointer(slot, ptr):
    shade(ptr)
    *slot = ptr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当执行类似 <code>*slot = ptr</code> 的表达式时，会执行上述写屏障通过 <code>shade</code> 函数尝试改变指针的颜色:</p><ul><li>如果 <code>ptr</code> 指针是<strong>白色</strong>的，那么该函数会将该对象设置成<strong>灰色</strong></li><li>其他情况则<strong>保持不变</strong></li></ul><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030414174.png" alt="dijkstra-insert-write-barrier" tabindex="0" loading="lazy"><figcaption>dijkstra-insert-write-barrier</figcaption></figure><p>插入写屏障的流程：</p><ol><li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色</li><li>用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色</li><li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色</li></ol><p>Dijkstra 的插入写屏障是一种相对保守的屏障技术，会将<strong>有存活可能的对象都标记成灰色</strong>以满足<strong>强三色不变性</strong>。</p><p>上图所示的流程中，实际上不再存活的 B 对象最后没有被回收，被错误标记的垃圾对象只有在<strong>下一个循环</strong>才会被回收。</p><p>缺点：</p><p>栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序。</p><h4 id="删除写屏障" tabindex="-1"><a class="header-anchor" href="#删除写屏障" aria-hidden="true">#</a> 删除写屏障</h4><p>由 Yuasa 提出，删除写屏障会保证开启写屏障时堆上所有对象的可达，所以也被称作快照垃圾收集（Snapshot GC）。</p><p>该算法会使用如下所示的写屏障保证增量或者并发执行垃圾收集时程序的正确性：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token function">writePointer</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span>
    <span class="token function">shade</span><span class="token punctuation">(</span><span class="token operator">*</span>slot<span class="token punctuation">)</span>
    <span class="token operator">*</span>slot <span class="token operator">=</span> ptr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<strong>老对象</strong>的引用<strong>被删除</strong>时，将<strong>白色</strong>的老对象涂成<strong>灰色</strong>，可以保证<strong>弱三色不变性</strong>，老对象引用的下游对象一定可以被灰色对象引用。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030419667.png" alt="yuasa-delete-write-barrier" tabindex="0" loading="lazy"><figcaption>yuasa-delete-write-barrier</figcaption></figure><p>删除写屏障的流程：</p><ol><li>圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色</li><li>用户程序将 A 对象原本指向 B 的指针指向 C，触发<strong>删除写屏障</strong>，但是因为 B 对象已经是灰色的，所以不做改变</li><li><strong>用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色</strong></li><li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色</li></ol><h3 id="增量和并发" tabindex="-1"><a class="header-anchor" href="#增量和并发" aria-hidden="true">#</a> 增量和并发</h3><p>传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序，一旦触发垃圾收集，垃圾收集器会抢占 CPU 的使用权占据大量的计算资源以完成标记和清除工作。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030424489.png" alt="stop-the-world-collector" tabindex="0" loading="lazy"><figcaption>stop-the-world-collector</figcaption></figure><p>为了<strong>减少</strong>应用程序暂停的最长时间和<strong>垃圾收集</strong>的总<strong>暂停时间</strong>，会使用下面的策略优化：</p><ol><li>增量垃圾收集：增量地标记和清除垃圾，降低应用程序暂停的最长时间</li><li>并发垃圾收集：利用多核的计算资源，在用户程序执行时并发标记和清除垃圾</li></ol><h4 id="增量收集器" tabindex="-1"><a class="header-anchor" href="#增量收集器" aria-hidden="true">#</a> 增量收集器</h4><p>增量式（Incremental）的垃圾收集可以将原本时间较长的<strong>暂停时间</strong>切分成多个<strong>更小的 GC 时间片</strong>，虽然从<strong>垃圾收集</strong>开始到结束的<strong>时间更长</strong>了，但是这也<strong>减少</strong>了应用程序<strong>暂停的最大时间</strong>：</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030426402.png" alt="incremental-collector" tabindex="0" loading="lazy"><figcaption>incremental-collector</figcaption></figure><h4 id="并发收集器" tabindex="-1"><a class="header-anchor" href="#并发收集器" aria-hidden="true">#</a> 并发收集器</h4><p>并发（Concurrent）的垃圾收集能够<strong>减少</strong>程序的<strong>最长暂停时间</strong>，还能<strong>减少</strong>整个<strong>垃圾收集</strong>阶段的<strong>时间</strong>，通过开启读写屏障、<strong>利用多核优势与用户程序并行执行</strong>，并发垃圾收集器能够减少垃圾收集对应用程序的影响：</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030428071.png" alt="concurrent-collector" tabindex="0" loading="lazy"><figcaption>concurrent-collector</figcaption></figure><h2 id="_7-2-2-golang-gc-的演进过程" tabindex="-1"><a class="header-anchor" href="#_7-2-2-golang-gc-的演进过程" aria-hidden="true">#</a> 7.2.2 Golang GC 的演进过程</h2><ol><li>v1.0：完全串行的标记和清除过程，需要暂停整个程序</li><li>v1.1：在多核主机并行执行垃圾收集的标记和清除阶段</li><li>v1.3：运行时基于<strong>只有指针类型的值包含指针</strong>的假设增加了对栈内存的精确扫描支持，实现了真正精确的垃圾收集</li><li>v1.5：实现了基于<strong>三色标记清扫的并发</strong>垃圾收集器</li><li>v1.6：实现了<strong>去中心化</strong>的垃圾收集协调器</li><li>v1.7：通过<strong>并行栈收缩</strong>将垃圾收集的时间缩短至 2ms 以内</li><li>v1.8：使用<strong>混合写屏障</strong>将垃圾收集的时间缩短至 0.5ms 以内</li><li>v1.9：彻底移除暂停程序的重新扫描栈的过程</li><li>v1.10：更新了垃圾收集调频器（Pacer）的实现，分离软硬堆大小的目标</li><li>v1.12：使用<strong>新的标记终止算法</strong>简化垃圾收集器的几个阶段</li><li>v1.13：通过新的 Scavenger 解决瞬时内存占用过高的应用程序向操作系统归还内存的问题</li><li>v1.14：使用全新的页分配器<strong>优化内存分配的速度</strong></li></ol><h3 id="并发垃圾收集" tabindex="-1"><a class="header-anchor" href="#并发垃圾收集" aria-hidden="true">#</a> 并发垃圾收集</h3><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030539618.png" alt="golang-concurrent-collector" tabindex="0" loading="lazy"><figcaption>golang-concurrent-collector</figcaption></figure><p>首先，并发垃圾收集器必须在合适的时间点触发垃圾收集循环，假设我们的 Go 语言程序运行在一台 4 核的物理机上，那么在垃圾收集开始后，收集器会占用 25% 计算资源在后台来扫描并标记内存中的对象。</p><p>Go 语言的并发垃圾收集器会在扫描对象之前暂停程序做一些标记对象的准备工作，其中包括启动后台标记的垃圾收集器以及开启写屏障，如果在后台执行的垃圾收集器不够快，应用程序申请内存的速度超过预期，运行时会让申请内存的应用程序辅助完成垃圾收集的扫描阶段，在标记和标记终止阶段结束之后就会进入异步的清理阶段，将不用的内存增量回收。</p><h3 id="回收堆目标" tabindex="-1"><a class="header-anchor" href="#回收堆目标" aria-hidden="true">#</a> 回收堆目标</h3><p>Go 语言运行时的默认配置会在堆内存达到上一次垃圾收集的 2 倍时，触发新一轮的垃圾收集，这个行为可以通过环境变量 <code>GOGC</code> 调整，在默认情况下它的值为 100，即增长 100% 的堆内存才会触发 GC。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030543603.png" alt="stop-the-world-garbage-collector-heap" tabindex="0" loading="lazy"><figcaption>stop-the-world-garbage-collector-heap</figcaption></figure><p>因为并发垃圾收集器会与程序一起运行，所以它无法准确的控制堆内存的大小，并发收集器需要在达到目标前触发垃圾收集，这样才能够保证内存大小的可控，并发收集器需要尽可能保证垃圾收集结束时的堆内存与用户配置的 <code>GOGC</code> 一致。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030546376.png" alt="concurrent-garbage-collector-heap" tabindex="0" loading="lazy"><figcaption>concurrent-garbage-collector-heap</figcaption></figure><p>并发垃圾收集器的同时使用垃圾收集调步（Pacing）算法计算触发的垃圾收集的最佳时间，确保触发的时间既不会浪费计算资源，也不会超出预期的堆大小。如上图所示，其中黑色的部分是上一次垃圾收集后标记的堆大小，绿色部分是上次垃圾收集结束后新分配的内存，因为我们使用并发垃圾收集，所以黄色的部分就是在垃圾收集期间分配的内存，最后的红色部分是垃圾收集结束时与目标的差值，我们希望尽可能减少红色部分内存，降低垃圾收集带来的额外开销以及程序的暂停时间。</p><h3 id="混合写屏障" tabindex="-1"><a class="header-anchor" href="#混合写屏障" aria-hidden="true">#</a> 混合写屏障</h3><p>混合写屏障<strong>将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色</strong>：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token function">writePointer</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token function">shade</span><span class="token punctuation">(</span><span class="token operator">*</span>slot<span class="token punctuation">)</span>
    <span class="token keyword">if</span> current stack is grey<span class="token punctuation">:</span>
        <span class="token function">shade</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
    <span class="token operator">*</span>slot <span class="token operator">=</span> ptr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的<strong>标记</strong>阶段，我们还需要<strong>将创建的所有新对象都标记成黑色</strong>，<strong>防止</strong>新分配的栈内存和堆内存中的对象被<strong>错误地回收</strong>，因为栈内存在标记阶段最终都会变为黑色，所以<strong>不再需要重新扫描栈空间</strong>。</p><h2 id="_7-2-3-实现原理" tabindex="-1"><a class="header-anchor" href="#_7-2-3-实现原理" aria-hidden="true">#</a> 7.2.3 实现原理</h2><h4 id="工作流程-1" tabindex="-1"><a class="header-anchor" href="#工作流程-1" aria-hidden="true">#</a> 工作流程</h4><p>Golang 垃圾收集可以分成清除终止、标记、标记终止和清除四个不同阶段，它们分别完成了不同的工作：</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030434814.png" alt="garbage-collector-phases" tabindex="0" loading="lazy"><figcaption>garbage-collector-phases</figcaption></figure><ol><li>清理终止阶段： <ol><li><strong>暂停程序</strong>，所有的处理器在这时会进入安全点（Safe point）</li><li>如果当前垃圾收集循环是强制触发的，还需要处理还未被清理的内存管理单元</li></ol></li><li>标记阶段： <ol><li>将状态切换至 <code>_GCmark</code>、开启写屏障、用户程序协助（Mutator Assists）并将根对象入队</li><li>恢复执行程序，标记进程和用于协助的用户程序会开始<strong>并发标记</strong>内存中的对象，<strong>写屏障</strong>会将<strong>被覆盖的指针</strong>和<strong>新指针</strong>都标记成<strong>灰色</strong>，而所有<strong>新创建的对象</strong>都会被直接标记成<strong>黑色</strong></li><li>开始<strong>扫描根对象</strong>，包括<strong>所有 Goroutine 的栈</strong>、<strong>全局对象</strong>以及<strong>不在堆中</strong>的运行时数据结构，<strong>扫描 Goroutine 栈</strong>期间会<strong>暂停</strong>当前处理器 P</li><li>依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色</li><li>使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段</li></ol></li><li>标记终止阶段： <ol><li><strong>暂停程序</strong>，将状态切换至 <code>_GCmarktermination</code> 并关闭辅助标记的用户程序</li><li>清理处理器上的线程缓存</li></ol></li><li>清理阶段： <ol><li>将状态切换至 <code>_GCoff</code> 开始清理阶段，初始化清理状态并关闭写屏障</li><li>恢复用户程序，所有<strong>新创建的对象</strong>会标记成<strong>白色</strong></li><li>后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理</li></ol></li></ol><h4 id="全局变量" tabindex="-1"><a class="header-anchor" href="#全局变量" aria-hidden="true">#</a> 全局变量</h4><p>垃圾收集中有一些比较重要的全局变量：</p>`,90),u={href:"https://draveness.me/golang/tree/runtime.gcphase",target:"_blank",rel:"noopener noreferrer"},d=n("code",null,"runtime.gcphase",-1),g=n("code",null,"_GCoff",-1),k=n("code",null,"_GCmark",-1),m=n("code",null,"_GCmarktermination",-1),h={href:"https://draveness.me/golang/tree/runtime.gcBlackenEnabled",target:"_blank",rel:"noopener noreferrer"},v=n("code",null,"runtime.gcBlackenEnabled",-1),_={href:"https://draveness.me/golang/tree/runtime.gcController",target:"_blank",rel:"noopener noreferrer"},f=n("code",null,"runtime.gcController",-1),b={href:"https://draveness.me/golang/tree/runtime.gcpercent",target:"_blank",rel:"noopener noreferrer"},w=n("code",null,"runtime.gcpercent",-1),y={href:"https://draveness.me/golang/tree/runtime.writeBarrier",target:"_blank",rel:"noopener noreferrer"},x=n("code",null,"runtime.writeBarrier",-1),G=n("code",null,"enabled",-1),z={href:"https://draveness.me/golang/tree/runtime.worldsema",target:"_blank",rel:"noopener noreferrer"},C=n("code",null,"runtime.worldsema",-1),T=n("h3",{id:"触发时机",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#触发时机","aria-hidden":"true"},"#"),s(" 触发时机")],-1),S={href:"https://draveness.me/golang/tree/runtime.gcTrigger.test",target:"_blank",rel:"noopener noreferrer"},j=n("code",null,"runtime.gcTrigger.test",-1),B=n("strong",null,"决定",-1),M=t(`<ol><li>允许垃圾收集</li><li>程序没有崩溃</li><li>没有处于垃圾收集循环</li></ol><p>会根据三种不同方式触发进行不同的检查：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>t gcTrigger<span class="token punctuation">)</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>memstats<span class="token punctuation">.</span>enablegc <span class="token operator">||</span> panicking <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> gcphase <span class="token operator">!=</span> _GCoff <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">switch</span> t<span class="token punctuation">.</span>kind <span class="token punctuation">{</span>
	<span class="token keyword">case</span> gcTriggerHeap<span class="token punctuation">:</span>
		<span class="token keyword">return</span> memstats<span class="token punctuation">.</span>heap_live <span class="token operator">&gt;=</span> memstats<span class="token punctuation">.</span>gc_trigger
	<span class="token keyword">case</span> gcTriggerTime<span class="token punctuation">:</span>
		<span class="token keyword">if</span> gcpercent <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span>
		<span class="token punctuation">}</span>
		lastgc <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>last_gc_nanotime<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> lastgc <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>now<span class="token operator">-</span>lastgc <span class="token operator">&gt;</span> forcegcperiod
	<span class="token keyword">case</span> gcTriggerCycle<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token function">int32</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>n<span class="token operator">-</span>work<span class="token punctuation">.</span>cycles<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),P=n("li",null,[n("code",null,"gcTriggerHeap"),s("：堆内存的分配达到控制器计算的触发堆大小")],-1),W=n("code",null,"gcTriggerTime",-1),F={href:"https://draveness.me/golang/tree/runtime.forcegcperiod",target:"_blank",rel:"noopener noreferrer"},A=n("code",null,"runtime.forcegcperiod",-1),D=n("li",null,[n("code",null,"gcTriggerCycle"),s(" ：如果当前没有开启垃圾收集，则触发新的循环")],-1),L={href:"https://draveness.me/golang/tree/runtime.gcStart",target:"_blank",rel:"noopener noreferrer"},E=n("code",null,"runtime.gcStart",-1),O={href:"https://draveness.me/golang/tree/runtime.gcTrigger",target:"_blank",rel:"noopener noreferrer"},N=n("code",null,"runtime.gcTrigger",-1),H={href:"https://draveness.me/golang/tree/runtime.gcTrigger",target:"_blank",rel:"noopener noreferrer"},I=n("code",null,"runtime.gcTrigger",-1),R={href:"https://draveness.me/golang/tree/runtime.sysmon",target:"_blank",rel:"noopener noreferrer"},V=n("code",null,"runtime.sysmon",-1),U={href:"https://draveness.me/golang/tree/runtime.forcegchelper",target:"_blank",rel:"noopener noreferrer"},q=n("code",null,"runtime.forcegchelper",-1),K={href:"https://draveness.me/golang/tree/runtime.GC",target:"_blank",rel:"noopener noreferrer"},Y=n("code",null,"runtime.GC",-1),Z={href:"https://draveness.me/golang/tree/runtime.mallocgc",target:"_blank",rel:"noopener noreferrer"},$=n("code",null,"runtime.mallocgc",-1),J=n("figure",null,[n("img",{src:"https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310030443997.png",alt:"garbage-collector-trigger",tabindex:"0",loading:"lazy"}),n("figcaption",null,"garbage-collector-trigger")],-1),Q=n("h4",{id:"后台触发",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#后台触发","aria-hidden":"true"},"#"),s(" 后台触发")],-1),X=n("strong",null,"后台",-1),nn=n("strong",null,"强制触发垃圾收集",-1),sn=n("strong",null,"Goroutine",-1),an={href:"https://draveness.me/golang/tree/runtime.gcStart",target:"_blank",rel:"noopener noreferrer"},en=n("code",null,"runtime.gcStart",-1),tn=t(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">go</span> <span class="token function">forcegchelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">forcegchelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	forcegc<span class="token punctuation">.</span>g <span class="token operator">=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>forcegc<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		atomic<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>forcegc<span class="token punctuation">.</span>idle<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token function">goparkunlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>forcegc<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> waitReasonForceGGIdle<span class="token punctuation">,</span> traceEvGoBlock<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token function">gcStart</span><span class="token punctuation">(</span>gcTrigger<span class="token punctuation">{</span>kind<span class="token punctuation">:</span> gcTriggerTime<span class="token punctuation">,</span> now<span class="token punctuation">:</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),on={href:"https://draveness.me/golang/tree/runtime.goparkunlock",target:"_blank",rel:"noopener noreferrer"},rn=n("code",null,"runtime.goparkunlock",-1),pn={href:"https://draveness.me/golang/tree/runtime.forcegchelper",target:"_blank",rel:"noopener noreferrer"},cn=n("code",null,"runtime.forcegchelper",-1),ln={href:"https://draveness.me/golang/tree/runtime.sysmon",target:"_blank",rel:"noopener noreferrer"},un=n("code",null,"runtime.sysmon",-1),dn=t(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">sysmon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token operator">...</span>
		<span class="token keyword">if</span> t <span class="token operator">:=</span> <span class="token punctuation">(</span>gcTrigger<span class="token punctuation">{</span>kind<span class="token punctuation">:</span> gcTriggerTime<span class="token punctuation">,</span> now<span class="token punctuation">:</span> now<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>forcegc<span class="token punctuation">.</span>idle<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>forcegc<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
			forcegc<span class="token punctuation">.</span>idle <span class="token operator">=</span> <span class="token number">0</span>
			<span class="token keyword">var</span> list gList
			list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>forcegc<span class="token punctuation">.</span>g<span class="token punctuation">)</span>
			<span class="token function">injectglist</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>list<span class="token punctuation">)</span>
			<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>forcegc<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),gn={href:"https://draveness.me/golang/tree/runtime.gcTrigger",target:"_blank",rel:"noopener noreferrer"},kn=n("code",null,"runtime.gcTrigger",-1),mn={href:"https://draveness.me/golang/tree/runtime.forcegc",target:"_blank",rel:"noopener noreferrer"},hn=n("code",null,"runtime.forcegc",-1),vn=n("h4",{id:"手动触发",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#手动触发","aria-hidden":"true"},"#"),s(" 手动触发")],-1),_n={href:"https://draveness.me/golang/tree/runtime.GC",target:"_blank",rel:"noopener noreferrer"},fn=n("code",null,"runtime.GC",-1),bn=t(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">GC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	n <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>cycles<span class="token punctuation">)</span>
	<span class="token function">gcWaitOnMark</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
	<span class="token function">gcStart</span><span class="token punctuation">(</span>gcTrigger<span class="token punctuation">{</span>kind<span class="token punctuation">:</span> gcTriggerCycle<span class="token punctuation">,</span> n<span class="token punctuation">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token function">gcWaitOnMark</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>cycles<span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sweepone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">^</span><span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		sweep<span class="token punctuation">.</span>nbgsweep<span class="token operator">++</span>
		<span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>cycles<span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mheap_<span class="token punctuation">.</span>sweepers<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	cycle <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>cycles<span class="token punctuation">)</span>
	<span class="token keyword">if</span> cycle <span class="token operator">==</span> n<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span>gcphase <span class="token operator">==</span> _GCmark <span class="token operator">&amp;&amp;</span> cycle <span class="token operator">==</span> n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">mProf_PostSweep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),wn={href:"https://draveness.me/golang/tree/runtime.gcWaitOnMark",target:"_blank",rel:"noopener noreferrer"},yn=n("code",null,"runtime.gcWaitOnMark",-1),xn={href:"https://draveness.me/golang/tree/runtime.gcStart",target:"_blank",rel:"noopener noreferrer"},Gn=n("code",null,"runtime.gcStart",-1),zn={href:"https://draveness.me/golang/tree/runtime.gcWaitOnMark",target:"_blank",rel:"noopener noreferrer"},Cn=n("code",null,"runtime.gcWaitOnMark",-1),Tn={href:"https://draveness.me/golang/tree/runtime.sweepone",target:"_blank",rel:"noopener noreferrer"},Sn=n("code",null,"runtime.sweepone",-1),jn={href:"https://draveness.me/golang/tree/runtime.Gosched",target:"_blank",rel:"noopener noreferrer"},Bn=n("code",null,"runtime.Gosched",-1),Mn={href:"https://draveness.me/golang/tree/runtime.mProf_PostSweep",target:"_blank",rel:"noopener noreferrer"},Pn=n("code",null,"runtime.mProf_PostSweep",-1),Wn=n("h4",{id:"申请内存",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#申请内存","aria-hidden":"true"},"#"),s(" 申请内存")],-1),Fn={href:"https://draveness.me/golang/tree/runtime.mallocgc",target:"_blank",rel:"noopener noreferrer"},An=n("code",null,"runtime.mallocgc",-1),Dn=t(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>size <span class="token builtin">uintptr</span><span class="token punctuation">,</span> typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> needzero <span class="token builtin">bool</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{</span>
	shouldhelpgc <span class="token operator">:=</span> <span class="token boolean">false</span>
	<span class="token operator">...</span>
	<span class="token keyword">if</span> size <span class="token operator">&lt;=</span> maxSmallSize <span class="token punctuation">{</span>
		<span class="token keyword">if</span> noscan <span class="token operator">&amp;&amp;</span> size <span class="token operator">&lt;</span> maxTinySize <span class="token punctuation">{</span>
			<span class="token operator">...</span>
			v <span class="token operator">:=</span> <span class="token function">nextFreeFast</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span>
			<span class="token keyword">if</span> v <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				v<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> shouldhelpgc <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">nextFree</span><span class="token punctuation">(</span>tinySpanClass<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token operator">...</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token operator">...</span>
			v <span class="token operator">:=</span> <span class="token function">nextFreeFast</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span>
			<span class="token keyword">if</span> v <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				v<span class="token punctuation">,</span> span<span class="token punctuation">,</span> shouldhelpgc <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">nextFree</span><span class="token punctuation">(</span>spc<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		  <span class="token operator">...</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		shouldhelpgc <span class="token operator">=</span> <span class="token boolean">true</span>
		<span class="token operator">...</span>
	<span class="token punctuation">}</span>
	<span class="token operator">...</span>
	<span class="token keyword">if</span> shouldhelpgc <span class="token punctuation">{</span>
		<span class="token keyword">if</span> t <span class="token operator">:=</span> <span class="token punctuation">(</span>gcTrigger<span class="token punctuation">{</span>kind<span class="token punctuation">:</span> gcTriggerHeap<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">gcStart</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> x
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),Ln={href:"https://draveness.me/golang/tree/runtime.mcache.nextFree",target:"_blank",rel:"noopener noreferrer"},En=n("code",null,"runtime.mcache.nextFree",-1),On={href:"https://draveness.me/golang/tree/runtime.gcTrigger",target:"_blank",rel:"noopener noreferrer"},Nn=n("code",null,"runtime.gcTrigger",-1),Hn=n("h3",{id:"垃圾收集启动",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#垃圾收集启动","aria-hidden":"true"},"#"),s(" 垃圾收集启动")],-1),In={href:"https://draveness.me/golang/tree/runtime.gcStart",target:"_blank",rel:"noopener noreferrer"},Rn=n("code",null,"runtime.gcStart",-1),Vn=n("code",null,"_GCmark",-1),Un={href:"https://draveness.me/golang/tree/runtime.gcTrigger.test",target:"_blank",rel:"noopener noreferrer"},qn=n("code",null,"runtime.gcTrigger.test",-1),Kn=n("li",null,"暂停程序、在后台启动用于处理标记任务的工作 Goroutine、确定所有内存管理单元都被清理以及其他标记阶段开始前的准备工作",-1),Yn=n("li",null,"进入标记阶段、准备后台的标记工作、根对象的标记工作以及微对象、恢复用户程序，进入并发扫描和标记阶段",-1),Zn=n("h3",{id:"并发扫描与标记辅助",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#并发扫描与标记辅助","aria-hidden":"true"},"#"),s(" 并发扫描与标记辅助")],-1),$n={href:"https://draveness.me/golang/tree/runtime.gcBgMarkWorker",target:"_blank",rel:"noopener noreferrer"},Jn=n("code",null,"runtime.gcBgMarkWorker",-1),Qn={href:"https://draveness.me/golang/tree/runtime.gcBgMarkWorkerNode",target:"_blank",rel:"noopener noreferrer"},Xn=n("code",null,"runtime.gcBgMarkWorkerNode",-1),ns=n("li",null,[s("根据处理器上的 "),n("code",null,"gcMarkWorkerMode"),s(" 模式决定扫描任务的策略")],-1),ss={href:"https://draveness.me/golang/tree/runtime.gcMarkDone",target:"_blank",rel:"noopener noreferrer"},as=n("code",null,"runtime.gcMarkDone",-1),es=n("h3",{id:"标记终止",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#标记终止","aria-hidden":"true"},"#"),s(" 标记终止")],-1),ts={href:"https://draveness.me/golang/tree/runtime.gcMarkDone",target:"_blank",rel:"noopener noreferrer"},os=n("code",null,"runtime.gcMarkDone",-1),rs=n("p",null,[s("当所有可达对象都被标记后，该函数会将垃圾收集的状态切换至 "),n("code",null,"_GCmarktermination"),s("。")],-1),ps=n("h3",{id:"内存清理",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#内存清理","aria-hidden":"true"},"#"),s(" 内存清理")],-1),is=n("p",null,"垃圾收集的清理中包含对象回收器（Reclaimer）和内存单元回收器，这两种回收器使用不同的算法清理堆内存：",-1),cs={href:"https://draveness.me/golang/tree/runtime.mspan",target:"_blank",rel:"noopener noreferrer"},ls=n("code",null,"runtime.mspan",-1),us={href:"https://draveness.me/golang/tree/runtime.mcentral.cacheSpan",target:"_blank",rel:"noopener noreferrer"},ds=n("code",null,"runtime.mcentral.cacheSpan",-1),gs={href:"https://draveness.me/golang/tree/runtime.sweepone",target:"_blank",rel:"noopener noreferrer"},ks=n("code",null,"runtime.sweepone",-1),ms={href:"https://draveness.me/golang/tree/runtime.mspan",target:"_blank",rel:"noopener noreferrer"},hs=n("code",null,"runtime.mspan",-1),vs={href:"https://draveness.me/golang/tree/runtime.mheap.reclaim",target:"_blank",rel:"noopener noreferrer"},_s=n("code",null,"runtime.mheap.reclaim",-1),fs=n("h2",{id:"reference",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),s(" Reference")],-1),bs={href:"https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/",target:"_blank",rel:"noopener noreferrer"};function ws(ys,xs){const a=i("ExternalLinkIcon");return r(),p("div",null,[l,n("ol",null,[n("li",null,[n("a",u,[d,e(a)]),s(" 是垃圾收集器当前处于的阶段，可能处于 "),g,s("、"),k,s(" 和 "),m,s("，Goroutine 在读取或者修改该阶段时需要保证原子性")]),n("li",null,[n("a",h,[v,e(a)]),s(" 是一个布尔值，当垃圾收集处于标记阶段时，该变量会被置为 1，在这里辅助垃圾收集的用户程序和后台标记的任务可以将对象涂黑")]),n("li",null,[n("a",_,[f,e(a)]),s(" 实现了垃圾收集的调步算法，它能够决定触发并行垃圾收集的时间和待处理的工作")]),n("li",null,[n("a",b,[w,e(a)]),s(" 是触发垃圾收集的内存增长百分比，默认情况下为 100，即堆内存相比上次垃圾收集增长 100% 时应该触发 GC，并行的垃圾收集器会在到达该目标前完成垃圾收集")]),n("li",null,[n("a",y,[x,e(a)]),s(" 是一个包含写屏障状态的结构体，其中的 "),G,s(" 字段表示写屏障的开启与关闭")]),n("li",null,[n("a",z,[C,e(a)]),s(" 是全局的信号量，获取该信号量的线程有权利暂停当前应用程序")])]),T,n("p",null,[s("运行时会通过"),n("a",S,[j,e(a)]),B,s("是否需要触发垃圾收集，当满足触发垃圾收集的基本条件时：")]),M,n("ol",null,[P,n("li",null,[W,s("：如果一定时间内没有触发，就会触发新的循环，该触发条件由 "),n("a",F,[A,e(a)]),s(" 变量控制，默认为 2 分钟")]),D]),n("p",null,[s("用于开启垃圾收集的方法 "),n("a",L,[E,e(a)]),s(" 会接收一个 "),n("a",O,[N,e(a)]),s(" 类型的谓词，所有出现 "),n("a",H,[I,e(a)]),s(" 结构体的位置都是触发垃圾收集的代码：")]),n("ol",null,[n("li",null,[n("a",R,[V,e(a)]),s(" 和 "),n("a",U,[q,e(a)]),s(" — 后台运行定时检查和垃圾收集")]),n("li",null,[n("a",K,[Y,e(a)]),s(" — 用户程序手动触发垃圾收集")]),n("li",null,[n("a",Z,[$,e(a)]),s(" — 申请内存时根据堆大小触发垃圾收集")])]),J,Q,n("p",null,[s("运行时会在应用程序启动时在"),X,s("开启一个用于"),nn,s("的 "),sn,s("，该 Goroutine 的职责非常简单 — 调用 "),n("a",an,[en,e(a)]),s(" 尝试启动新一轮的垃圾收集：")]),tn,n("p",null,[s("为了减少对计算资源的占用，该 Goroutine 会在循环中调用 "),n("a",on,[rn,e(a)]),s(" 主动陷入休眠等待其他 Goroutine 的唤醒，"),n("a",pn,[cn,e(a)]),s(" 在大多数时间都是陷入休眠的，但是它会被系统监控器 "),n("a",ln,[un,e(a)]),s(" 在满足垃圾收集条件时唤醒：")]),dn,n("p",null,[s("系统监控在每个循环中都会主动构建一个 "),n("a",gn,[kn,e(a)]),s(" 并检查垃圾收集的触发条件是否满足，如果满足条件，系统监控会将 "),n("a",mn,[hn,e(a)]),s(" 状态中持有的 Goroutine 加入全局队列等待调度器的调度。")]),vn,n("p",null,[s("用户程序会通过 "),n("a",_n,[fn,e(a)]),s(" 函数在程序运行期间主动通知运行时执行，该方法在调用时会阻塞调用方直到当前垃圾收集循环完成，在垃圾收集期间也可能会通过 STW 暂停整个程序：")]),bn,n("ol",null,[n("li",null,[s("在正式开始垃圾收集前，运行时需要通过 "),n("a",wn,[yn,e(a)]),s(" 等待上一个循环的标记终止、标记和清除终止阶段完成；")]),n("li",null,[s("调用 "),n("a",xn,[Gn,e(a)]),s(" 触发新一轮的垃圾收集并通过 "),n("a",zn,[Cn,e(a)]),s(" 等待该轮垃圾收集的标记终止阶段正常结束；")]),n("li",null,[s("持续调用 "),n("a",Tn,[Sn,e(a)]),s(" 清理全部待处理的内存管理单元并等待所有的清理工作完成，等待期间会调用 "),n("a",jn,[Bn,e(a)]),s(" 让出处理器；")]),n("li",null,[s("完成本轮垃圾收集的清理工作后，通过 "),n("a",Mn,[Pn,e(a)]),s(" 将该阶段的堆内存状态快照发布出来，我们可以获取这时的内存状态；")])]),Wn,n("p",null,[s("使用"),n("a",Fn,[An,e(a)]),s("申请内存时，对于微对象、小对象和大对象三类的创建都可能会触发新的垃圾收集循环：")]),Dn,n("ol",null,[n("li",null,[s("当前线程的内存管理单元中不存在空闲空间时，创建微对象和小对象需要调用 "),n("a",Ln,[En,e(a)]),s(" 从中心缓存或者页堆中获取新的管理单元，在这时就可能触发垃圾收集")]),n("li",null,[s("当用户程序申请分配 32KB 以上的大对象时，一定会构建 "),n("a",On,[Nn,e(a)]),s(" 结构体尝试触发垃圾收集")])]),Hn,n("p",null,[s("垃圾收集在启动过程调用 "),n("a",In,[Rn,e(a)]),s("，主要职责是修改全局的垃圾收集状态到 "),Vn,s(" 并做一些准备工作，流程为：")]),n("ol",null,[n("li",null,[s("两次调用 "),n("a",Un,[qn,e(a)]),s(" 检查是否满足垃圾收集条件")]),Kn,Yn]),Zn,n("p",null,[n("a",$n,[Jn,e(a)]),s(" 是后台的标记任务执行的函数，该函数的循环中执行了对内存中对象图的扫描和标记，流程如下：")]),n("ol",null,[n("li",null,[s("获取当前处理器以及 Goroutine 打包成"),n("a",Qn,[Xn,e(a)]),s(" 类型的结构并主动陷入休眠等待唤醒")]),ns,n("li",null,[s("所有标记任务都完成后，调用 "),n("a",ss,[as,e(a)]),s(" 方法完成标记阶段")])]),es,n("p",null,[s("当所有处理器的本地任务都完成并且不存在剩余的工作 Goroutine 时，后台并发任务或者辅助标记的用户程序会调用 "),n("a",ts,[os,e(a)]),s(" 通知垃圾收集器。")]),rs,ps,is,n("ol",null,[n("li",null,[s("对象回收器在内存管理单元中查找并释放未被标记的对象，但是如果 "),n("a",cs,[ls,e(a)]),s(" 中的所有对象都没有被标记，整个单元就会被直接回收，该过程会被 "),n("a",us,[ds,e(a)]),s(" 或者 "),n("a",gs,[ks,e(a)]),s(" 异步触发；")]),n("li",null,[s("内存单元回收器会在内存中查找所有的对象都未被标记的 "),n("a",ms,[hs,e(a)]),s("，该过程会被 "),n("a",vs,[_s,e(a)]),s(" 触发；")])]),fs,n("ol",null,[n("li",null,[n("a",bs,[s("https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/"),e(a)])])])])}const zs=o(c,[["render",ws],["__file","07.2.gc.html.vue"]]);export{zs as default};
