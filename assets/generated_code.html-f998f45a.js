import{_ as t,Z as a,$ as o,a0 as e,a1 as n,a2 as r,a3 as c,H as i}from"./framework-09afcf0b.js";const d={},l=c(`<p><strong>Thread-safety</strong>: note that client-side RPC invocations and server-side RPC handlers are <em>thread-safe</em> and are meant to be run on concurrent goroutines. But also note that for individual streams, incoming and outgoing data is bi-directional but serial; so e.g. <em>inidividual</em> streams do not support concurrent reads or concurrent writes (but reads are safely concurrent with writes).</p><h2 id="_1-methods-on-generated-server" tabindex="-1"><a class="header-anchor" href="#_1-methods-on-generated-server" aria-hidden="true">#</a> 1. Methods on generated server</h2><p>On the server side, each <code>service Bar</code> in the <code>.proto</code> file results in the function:</p><p><code>func RegisterBarService(s *grpc.Server, srv BarServer)</code></p><p>The application can define a concrete implementation of the <code>BarServer</code> interface and register it with a <code>gprc.Server</code> instance (before starting the server instance) by using this function.</p><h3 id="_1-1-unary-methods" tabindex="-1"><a class="header-anchor" href="#_1-1-unary-methods" aria-hidden="true">#</a> 1.1 Unary methods</h3><p>These methods have the following signature on the generated service interface:</p><p><code>Foo(context.Context, *MsgA) (*MsgB, error)</code></p><p>In this context, <code>MsgA</code> is the protobuf message sent from the client, and <code>MsgB</code> is the protobuf message sent back from the server.</p><h3 id="_1-2-server-streaming-methods" tabindex="-1"><a class="header-anchor" href="#_1-2-server-streaming-methods" aria-hidden="true">#</a> 1.2 Server-streaming methods</h3><p>These methods have the following signature on the generated service interface:</p><p><code>Foo(*MsgA, &lt;ServiceName&gt;_FooServer) error</code></p><p>In this context, <code>MsgA</code> is the single request from the client, and the <code>&lt;ServiceName&gt;_FooServer</code> parameter represents the server-to-client stream of <code>MsgB</code> messages.</p><p><code>&lt;ServiceName&gt;_FooServer</code> has an embedded <code>grpc.ServerStream</code> and the following interface:</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> <span class="token operator">&lt;</span>ServiceName<span class="token operator">&gt;</span>_FooServer <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Send</span><span class="token punctuation">(</span><span class="token operator">*</span>MsgB<span class="token punctuation">)</span> <span class="token builtin">error</span>
    grpc<span class="token punctuation">.</span>ServerStream
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The server-side handler can send a stream of protobuf messages to the client through this parameterâ€™s <code>Send</code> method. End-of-stream for the server-to-client stream is caused by the <code>return</code> of the handler method.</p><h3 id="_1-3-client-streaming-methods" tabindex="-1"><a class="header-anchor" href="#_1-3-client-streaming-methods" aria-hidden="true">#</a> 1.3 Client-streaming methods</h3><p>These methods have the following signature on the generated service interface:</p><p><code>Foo(&lt;ServiceName_FooServer) error</code></p><p>In this context, <code>&lt;SerivceName&gt;_FooServer</code> can be used both to read the client-to-server message stream and to send the single server response message.</p><p><code>&lt;ServiceName&gt;_FooServer</code> has an embedded <code>gprc.ServerStream</code> and the following interface:</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> <span class="token operator">&lt;</span>ServiceName<span class="token operator">&gt;</span>_FooServer <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">SendAndClose</span><span class="token punctuation">(</span><span class="token operator">*</span>MsgA<span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token function">Recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>MsgB<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    grpc<span class="token punctuation">.</span>ServerStream
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The server-side handler can repeatedly call <code>Recv</code> on this parameter in order to receive the full stream of messages from the client. <code>Recv</code> returns <code>(nil, io.EOF)</code> once it has reached the end of the stream. The single response message from the server is sent by calling the <code>SendAndClose</code> method on this <code>&lt;ServiceName&gt;_FooServer</code> parameter. Note that <code>SendAndClose</code> must be called once and only once.</p><h3 id="_1-4-bidi-streaming-methods" tabindex="-1"><a class="header-anchor" href="#_1-4-bidi-streaming-methods" aria-hidden="true">#</a> 1.4 Bidi-streaming methods</h3><p>These methods have the following signature on the generated service interface:</p><p><code>Foo(&lt;ServiceName&gt;_FooServer) error</code></p><p>In this context, <code>&lt;ServiceName&gt;_FooServer</code> can be used to access both the client-to-server message stream and the server-to-client message stream. <code>&lt;ServiceName&gt;_FooServer</code> has an embedded <code>gprc.ServerStream</code> and the following interface:</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> <span class="token operator">&lt;</span>ServiceName<span class="token operator">&gt;</span>_FooServer <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Send</span><span class="token punctuation">(</span><span class="token operator">*</span>MsgA<span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token function">Recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>MsgB<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    grpc<span class="token punctuation">.</span>ServerStream
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The server-side handler can repeatedly call <code>Recv</code> on this parameter in order to read the client-to-server message stream. <code>Recv</code> returns <code>(nil, io.EOF)</code> once it has reached the end of the client-to-server stream. The response server-to-client message stream is sent by repeatedly calling the <code>Send</code> method of on this <code>&lt;ServiceName&gt;_FooServer</code> parameter. End-of-stream for the server-to-client stream is indicated by the <code>return</code> of the bidi method handler.</p><h1 id="_2-methods-on-generated-client-interfaces" tabindex="-1"><a class="header-anchor" href="#_2-methods-on-generated-client-interfaces" aria-hidden="true">#</a> 2. Methods on generated client interfaces</h1><p>For client side usage, each <code>service Bar</code> in the <code>.proto</code> file also results in the function: <code>func BarClient(cc *grpc.ClientConn) BarClient</code>, which returns a concrete implementation of the <code>BarClient</code> interface (this concrete implementation also lives in the generated <code>.pb.go</code> file).</p><h3 id="_2-1-unary-methods" tabindex="-1"><a class="header-anchor" href="#_2-1-unary-methods" aria-hidden="true">#</a> 2.1 Unary Methods</h3><p>These methods have the following signature on the generated client stub:</p><p><code>Foo(ctx context.Context, in *MsgA, opts ...grpc.CallOption) (*MsgB, error)</code></p><p>In this context, <code>MsgA</code> is the single request from client to server, and <code>MsgB</code> contains the response sent back from the server.</p><h3 id="_2-2-server-streaming-methods" tabindex="-1"><a class="header-anchor" href="#_2-2-server-streaming-methods" aria-hidden="true">#</a> 2.2 Server-Streaming methods</h3><p>These methods have the following signature on the generated client stub:</p><p><code>Foo(ctx context.Context, in *MsgA, opts ...grpc.CallOption) (&lt;ServiceName&gt;_FooClient, error)</code></p><p>In this context, <code>&lt;ServiceName&gt;_FooClient</code> represents the server-to-client <code>stream</code> of <code>MsgB</code> messages.</p><p>This stream has an embedded <code>grpc.ClientStream</code> and the following interface:</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> <span class="token operator">&lt;</span>ServiceName<span class="token operator">&gt;</span>_FooClient <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>MsgB<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    gprc<span class="token punctuation">.</span>ClientStream
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The stream begins when the client calls the <code>Foo</code> method on the stub. The client can then repeatedly call the <code>Recv</code> method on the returned <code>&lt;ServiceName&gt;_FooClient</code> stream in order to read the server-to-client response stream. This <code>Recv</code> method returns <code>(nil, io.EOF)</code> once the server-to-client stream has been completely read through.</p><h3 id="_2-3-client-streaming-methods" tabindex="-1"><a class="header-anchor" href="#_2-3-client-streaming-methods" aria-hidden="true">#</a> 2.3 Client-Streaming methods</h3><p>These methods have the following signature on the generated client stub:</p><p><code>Foo(ctx context.Context,opts ...gprc.CallOption) (&lt;ServiceName&gt;_FooClient, error)</code></p><p>In this context, <code>&lt;ServiceName&gt;_FooClient</code> represents the client-to-server <code>stream</code> of <code>MsgA</code> messages.</p><p><code>&lt;ServiceName&gt;_FooClient</code> has an embedded <code>grpc.ClientStream</code> and the following interface:</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> <span class="token operator">&lt;</span>ServiceName<span class="token operator">&gt;</span>_FooClient <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Send</span><span class="token punctuation">(</span><span class="token operator">*</span>MsgA<span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token function">CloseAndRecv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>MsgB<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    grpc<span class="token punctuation">.</span>ClientStream
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The stream begins when the client calls the <code>Foo</code> method on the stub. The client can then repeatedly call the <code>Send</code> method on the returned <code>&lt;ServiceName&gt;_FooClient</code> stream in order to send the client-to-server message stream. The <code>CloseAndRecv</code> method on this stream must be called once and only once, in order to both close the client-to-server stream and receive the single response message from the server.</p><h3 id="_2-4-bidi-streaming-methods" tabindex="-1"><a class="header-anchor" href="#_2-4-bidi-streaming-methods" aria-hidden="true">#</a> 2.4 Bidi-Streaming methods</h3><p>These methods have the following signature on the generated client stub:</p><p><code>Foo(ctx context.Context, opts ...grpc.Option) (&lt;ServiceName&gt;_FooClient, error)</code></p><p>In this context, <code>&lt;ServiceName&gt;_FooClient</code> represents both the client-to-server and server-to-client message streams.</p><p><code>&lt;ServiceName&gt;_FooClient</code> has an embedded <code>grpc.ClientStream</code> and the following interface:</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> <span class="token operator">&lt;</span>ServiceName<span class="token operator">&gt;</span>_FooClient <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Send</span><span class="token punctuation">(</span><span class="token operator">*</span>MsgA<span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token function">Recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>MsgB<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    grpc<span class="token punctuation">.</span>ClientStream
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The stream begins when the client calls the <code>Foo</code> method on the stub. The client can then repeatedly call the <code>Send</code> method on the returned <code>&lt;ServiceName&gt;_FooClient</code> stream in order to send the client-to-server message stream. The client can also repeatedly call <code>Recv</code> on this stream in order to receive the full server-to-client message stream.</p><p>End-of-Stream for the server-to-client stream is indicated by a return value of <code>(nil, io.EOF)</code> on the <code>Recv</code> method of the stream. End-of-stream for the client-to-server stream can be indicated from the client by calling the <code>CloseSend</code> method on the stream.</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2>`,58),p={href:"https://grpc.io/docs/languages/go/generated-code/",target:"_blank",rel:"noopener noreferrer"};function h(u,m){const s=i("ExternalLinkIcon");return a(),o("div",null,[l,e("ol",null,[e("li",null,[e("a",p,[n("generated-code"),r(s)]),n(" gRPC docs")])])])}const v=t(d,[["render",h],["__file","generated_code.html.vue"]]);export{v as default};
