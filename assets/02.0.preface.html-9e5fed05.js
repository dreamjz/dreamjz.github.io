import{_ as o,Z as n,$ as c,a0 as e,a1 as a,a2 as t,a3 as l,H as i}from"./framework-09afcf0b.js";const h={},s=l('<h2 id="_1-分布式缓存" tabindex="-1"><a class="header-anchor" href="#_1-分布式缓存" aria-hidden="true">#</a> 1. 分布式缓存</h2><p>缓存的设计随处可见，例如：</p><ul><li>浏览器缓存，访问网页时会优先从缓存中读取</li><li>I/O 缓存，计算机写入数据到硬盘时，会先缓存到内存中然后一次写入</li><li>Redis 缓存，对即时性要求较高的某些数据会缓存在 Redis 集群之中</li><li>...</li></ul><h3 id="_1-1-键值对缓存" tabindex="-1"><a class="header-anchor" href="#_1-1-键值对缓存" aria-hidden="true">#</a> 1.1 键值对缓存</h3><p>使用哈希表实现键值对缓存是最简单的实现方式，但是存在一些问题：</p><ol><li>淘汰策略 当内存不够时，需要删除数据，需要一个淘汰策略来合理的删除一些数据</li><li>并发冲突 <code>map</code>不是并发安全的，需要额外的加锁</li><li>单机性能 单机性能是有瓶颈的，此时需要考虑分布式系统</li><li>...</li></ol><h2 id="_2-分布式缓存系统" tabindex="-1"><a class="header-anchor" href="#_2-分布式缓存系统" aria-hidden="true">#</a> 2. 分布式缓存系统</h2>',7),d=e("code",null,"geeCache",-1),_={href:"https://github.com/golang/groupcache",target:"_blank",rel:"noopener noreferrer"},p=e("h2",{id:"reference",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#reference","aria-hidden":"true"},"#"),a(" Reference")],-1),u={href:"https://geektutu.com/post/geecache.html",target:"_blank",rel:"noopener noreferrer"};function f(m,g){const r=i("ExternalLinkIcon");return n(),c("div",null,[s,e("p",null,[d,a(" 参照 "),e("a",_,[a("groupcache"),t(r)]),a("实现一个简单的分布式缓存系统。")]),p,e("ol",null,[e("li",null,[e("a",u,[a("https://geektutu.com/post/geecache.html"),t(r)])])])])}const k=o(h,[["render",f],["__file","02.0.preface.html.vue"]]);export{k as default};
