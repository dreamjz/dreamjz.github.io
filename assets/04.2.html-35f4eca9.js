import{_ as o,Z as p,$ as t,a0 as n,a1 as s,a2 as e,a3 as c,H as l}from"./framework-dee406ed.js";const r={},i=c(`<h2 id="_4-2-protobuf" tabindex="-1"><a class="header-anchor" href="#_4-2-protobuf" aria-hidden="true">#</a> 4.2 Protobuf</h2><p>Protobuf ( Protocol Buffer ) 是 Google 开发的数据描述语言，可以作为跨语言的 RPC</p><p>序列化数据格式。</p><h3 id="_4-2-1-protobuf-入门" tabindex="-1"><a class="header-anchor" href="#_4-2-1-protobuf-入门" aria-hidden="true">#</a> 4.2.1 Protobuf 入门</h3><p>下面将 Protobuf 和 RPC 结合在一起使用，通过 Protobuf 确保 RPC 的接口安全和规范。</p><p>首先创建 <code>hello.proto</code> ，其中包装了 HelloService 服务中用到的字符串类型</p><div class="language-protobuf line-numbers-mode" data-ext="protobuf"><pre class="language-protobuf"><code><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">&quot;proto3&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">package</span> main<span class="token punctuation">;</span>

<span class="token keyword">option</span> go_pacakge <span class="token operator">=</span> <span class="token string">&quot;../protobuffers&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 需要指定 go package </span>

<span class="token keyword">message</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
	<span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>syntax</code> : “proto3” 表示采用 proto3 语法第三版的 Protobuf 对语言进行了简化，所有成员均采用零值初始化（不在支持自定义默认值），因此成员不需要支持 require 特性</li><li><code>package</code>: “main” 指定当前包名, 可以自定义包路径和名称，这里和 Go 包名保持一致以简化代码</li><li><code>option go_pacakge</code>: 决定生成文件的路径及文件包名</li></ul><p>在 XML 或 JSON 等数据描述语言中，一般通过成员名称绑定对应的数据。Protobuf 编码通过成员的唯一编号来绑定对应数据，因此 Protobuf 编码后的数据的体积比较小。</p><p>要将 <code>.proto</code> 编译成 Go code，需要安装 protobuf 编译器和 Golang 插件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># protoc, 本人开发环境为 Manjaro 直接使用 pacman 安装</span>
<span class="token function">sudo</span> pacman <span class="token parameter variable">-S</span> protoc
<span class="token comment"># 安装插件</span>
<span class="token comment"># github.com/golang/protobuf/protoc-gen-go 已经过时</span>
go <span class="token function">install</span> google.golang.org/protobuf/cmd/protoc-gen-go@latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成 go code :</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>. hello.proto
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>引入 proto 依赖：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>go get <span class="token parameter variable">-u</span> google.golang.org/protobuf/proto
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>基于生成的代码，重新实现 HelloService 服务</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">package</span> rpc_objects

<span class="token keyword">import</span> pb <span class="token string">&quot;rpc-and-protobuf/hello-protobuf/protobuffers&quot;</span>

<span class="token keyword">type</span> HelloService <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>HelloService<span class="token punctuation">)</span> <span class="token function">Hello</span><span class="token punctuation">(</span>request <span class="token operator">*</span>pb<span class="token punctuation">.</span>User<span class="token punctuation">,</span> reply <span class="token operator">*</span>pb<span class="token punctuation">.</span>User<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	reply<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">&quot;Hello: &quot;</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的 Hello 方法的输入参数和输出参数均改用 Protobuf 定义的 User 类型表示，因为新的输入参数为结构体类型，因此改用指针类型作为输入参数。</p><p>至此，初步实现了 Protobuf 和 RPC 组合工作。但是在启动 RPC 服务时，依然可以选择 gob 或 json 编码，并未提现出 protobuf 的特性。在之前的示例中为 RPC 服务添加了安全保障，但是得到的代码本身需要非常繁琐的手工维护并且仅适用于 Golang 环境。</p><p>我们可以通过在 Protobuf 中定义 RPC 服务来生成 RPC 代码，避免了繁琐的人工维护。</p><p>下面在 <code>hello.proto</code> 中定义 <code>HelloService</code> 服务</p><div class="language-protobuf line-numbers-mode" data-ext="protobuf"><pre class="language-protobuf"><code><span class="token keyword">service</span> <span class="token class-name">HelloService</span> <span class="token punctuation">{</span>
	<span class="token keyword">rpc</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> <span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是直接重新生成的代码并未发生变化，因为 RPC 实现有很多，protoc 编译器并不直到如何生成服务代码。</p><blockquote><p>不过在 <code>protoc-gen-go</code> 中集成了 <code>grpc</code> 插件用于生成<code>gRPC</code> 代码</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>protoc <span class="token parameter variable">--go_out</span><span class="token operator">=</span>plugins<span class="token operator">=</span>grpc: <span class="token builtin class-name">.</span> hello.proto
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><p>新的 <code>google.golang.org/protobuf/cmd/protoc-gen-go</code> 不支持 gRpc 插件，需要使用 <code>google.golang.org/grpc/cmd/protoc-gen-go-grpc</code> 来生成.</p><p>// TODO: 实现自定义的 protoc 插件</p><ul><li>阅读 protoc 官方文档, 了解插件的实现原理</li><li>阅读相关博客进行实践</li></ul><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2>`,28),d={href:"https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-02-pb-intro.html",target:"_blank",rel:"noopener noreferrer"},u={href:"https://developers.google.com/protocol-buffers",target:"_blank",rel:"noopener noreferrer"};function b(g,k){const a=l("ExternalLinkIcon");return p(),t("div",null,[i,n("ol",null,[n("li",null,[n("a",d,[s("4.2 Protobuf"),e(a)]),s(" Advanced Go Programming")]),n("li",null,[n("a",u,[s("protocol buffers"),e(a)]),s(" google docs")])])])}const m=o(r,[["render",b],["__file","04.2.html.vue"]]);export{m as default};
