import{_ as a,Z as i,$ as r,a3 as t}from"./framework-09afcf0b.js";const e={},n=t('<h2 id="_1-tcp-三次握手和四次挥手" tabindex="-1"><a class="header-anchor" href="#_1-tcp-三次握手和四次挥手" aria-hidden="true">#</a> 1. TCP 三次握手和四次挥手</h2><h3 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手" aria-hidden="true">#</a> 三次握手</h3><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/format.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>客户端发送<strong>连接请求报文（SYN = 1，seq = x）</strong>，客户端进入 SYN-SENT （<strong>同步已发送</strong>）状态。<mark>TCP 规定，SYN 报文（SYN = 1），不能携带数据，但需要消耗一个序列号。</mark></li><li>TCP 服务器收到请求报文后，若同意连接，则发出<strong>确认报文（SYN = 1，ACK = 1，ack = x+1，seq = y）</strong>， TCP 服务器进入 **SYN-RCVD （同步接收）**状态。<mark>此报文无法携带数据，需要消耗一个序列号。</mark></li><li>TCP 客户端收到后，向服务器发送<strong>确认报文（ACK = 1， ack = y+1，seq = x+1）</strong>。此时连接建立，客户端进入<strong>连接已建立 （ESTABLISHED）状态</strong>。<mark>此报文可携带数据，若无数据则不消耗序列号</mark>。</li><li>当服务器收到客户端的确认报文后，进入**连接已建立（ESTABLISHED）**状态。</li></ol><h3 id="为何需要三次握手" tabindex="-1"><a class="header-anchor" href="#为何需要三次握手" aria-hidden="true">#</a> 为何需要三次握手</h3><p>确认双方的<strong>接收和发送均正常</strong>和<strong>防止</strong>滞留的连接报文到达服务器，<strong>建立无效连接</strong>导致资源浪费。</p><ol><li>客户端发送连接请求报文 （SYN = 1，seq = x），服务端接收。 <ul><li>C: 无法确认状态；</li><li>S: 确认 C 端发送正常，S 端接收正常；</li></ul></li><li>服务端发送确认报文 （SYN = 1，ACK = 1，ack = x+1，seq = y），客户端接收。 <ul><li>C: 确认 C 端发送和接收正常，S 端发送和接收正常；</li><li>S: 无法确认状态；</li></ul></li><li>客户端发送确认报文 （ACK = 1，seq = x+1，ack = y+1），服务端接收。 <ul><li>C: 无需确认状态；</li><li>S: 确认 C 端接收正常，S 端发送正常；</li></ul></li></ol><h3 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手" aria-hidden="true">#</a> 四次挥手</h3><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/format,png-16500101709586.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>客户端发送<strong>连接释放报文（FIN = 1，seq = u）</strong>，停止发送数据，进入 **终止等待-1（FIN-WAIT-1）**状态。<mark>TCP 规定，FIN 报文即使不携带数据也要消耗一个序号</mark>。</li><li>服务端接收后，发送<strong>确认报文（ACK = 1，ack = u+1，seq = v）</strong>，服务端进入 **关闭等待（CLOSE-WAIT）**状态。</li><li>客户端接收后，进入**终止等待-2（FIN-WAIT-2）**状态。此时可以接收服务器报文。</li><li>服务器数据发送完毕后，发送<strong>连接释放报文（FIN = 1，ACK = 1，ack = u+1，seq = w）</strong>，服务器进入**最后确认（LAST-ACK）**状态。</li><li>客户端收到服务器后，发出确认报文（ACK = 1，ack = w+1，seq = u+1）。此时，客户端进入 **TIME-WAIT （时间等待）**状态。客户端在经过 <strong>2MSL</strong>（最长报文寿命） 后才会进入 <strong>CLOSED</strong> 状态。</li><li>服务端接收到了确认报文，就会进入 <strong>CLOSED</strong> 状态。</li></ol><h3 id="为何等待-2msl" tabindex="-1"><a class="header-anchor" href="#为何等待-2msl" aria-hidden="true">#</a> 为何等待 2MSL</h3><p>确保服务器能够收到连接释放的确认报文。若客户端发送的 ACK 报文没有被收到，则服务端会重新发送 FIN + ACK 报文。客户端收到并发送 ACK 后，再次进入 TIME-WAIT 状态。</p><h3 id="为何需要四次握手" tabindex="-1"><a class="header-anchor" href="#为何需要四次握手" aria-hidden="true">#</a> 为何需要四次握手</h3><p>基于 TCP 的半关闭（half-close）的特性。</p><p>客户端发送连接释放的通知后进入半关闭状态（不发送，只接受），服务端发送完数据后，通知连接释放，此时 TCP 进入关闭状态。</p>',15),s=[n];function l(o,c){return i(),r("div",null,s)}const g=a(e,[["render",l],["__file","network.html.vue"]]);export{g as default};
