const e=JSON.parse('{"key":"v-25febabc","path":"/note/rpc/gRPC/introduction.html","title":"Introduction to gRPC","lang":"zh-CN","frontmatter":{"title":"Introduction to gRPC","date":"2021-12-29T00:00:00.000Z","category":["golang","rpc"],"tag":["grpc"],"timeline":true},"headers":[{"level":2,"title":"1. Overview","slug":"_1-overview","link":"#_1-overview","children":[]},{"level":2,"title":"2. Working with Protocol Buffers","slug":"_2-working-with-protocol-buffers","link":"#_2-working-with-protocol-buffers","children":[]},{"level":2,"title":"3. Core concepts","slug":"_3-core-concepts","link":"#_3-core-concepts","children":[{"level":3,"title":"3.1 Service definition","slug":"_3-1-service-definition","link":"#_3-1-service-definition","children":[]},{"level":3,"title":"3.2 Using the API","slug":"_3-2-using-the-api","link":"#_3-2-using-the-api","children":[]},{"level":3,"title":"3.3 Synchronous vs. asynchronous","slug":"_3-3-synchronous-vs-asynchronous","link":"#_3-3-synchronous-vs-asynchronous","children":[]}]},{"level":2,"title":"4. RPC life cycle","slug":"_4-rpc-life-cycle","link":"#_4-rpc-life-cycle","children":[{"level":3,"title":"4.1 Unary RPC","slug":"_4-1-unary-rpc","link":"#_4-1-unary-rpc","children":[]},{"level":3,"title":"4.2 Server streaming RPC","slug":"_4-2-server-streaming-rpc","link":"#_4-2-server-streaming-rpc","children":[]},{"level":3,"title":"4.3 Client streaming RPC","slug":"_4-3-client-streaming-rpc","link":"#_4-3-client-streaming-rpc","children":[]},{"level":3,"title":"4.4 Bidirectional streaming RPC","slug":"_4-4-bidirectional-streaming-rpc","link":"#_4-4-bidirectional-streaming-rpc","children":[]},{"level":3,"title":"4.5 Deadlines/Timeouts","slug":"_4-5-deadlines-timeouts","link":"#_4-5-deadlines-timeouts","children":[]},{"level":3,"title":"4.6 RPC termination","slug":"_4-6-rpc-termination","link":"#_4-6-rpc-termination","children":[]},{"level":3,"title":"4.6 Cancelling an RPC","slug":"_4-6-cancelling-an-rpc","link":"#_4-6-cancelling-an-rpc","children":[]},{"level":3,"title":"4.7 Metadata","slug":"_4-7-metadata","link":"#_4-7-metadata","children":[]},{"level":3,"title":"4.8 Channels","slug":"_4-8-channels","link":"#_4-8-channels","children":[]}]},{"level":2,"title":"Reference","slug":"reference","link":"#reference","children":[]}],"readingTime":{"minutes":5.85,"words":1754},"filePathRelative":"note/rpc/gRPC/introduction.md","localizedDate":"2021年12月29日","excerpt":"<p>gRPC can use protocol buffers as both its <em>Interface Definition Language</em> (<strong>IDL</strong>) and as its underlying message interchange format.</p>\\n<h2> 1. Overview</h2>\\n<p>In gRPC, a client application can directly call a method on a server application on a different machine as if it were a local object, making it easier for you to create distributed applications and services. As in many RPC systems, gRPC is based around the idea of defining a service, specifying the methods that can be called remotely with their parameters and return types. On the server side, the server implements this interface and runs a gRPC server to handle client calls. On the client side, the client has a stub (referred to as just a client in some languages) that provides the same methods as the server.</p>"}');export{e as data};
