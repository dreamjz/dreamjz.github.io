const e=JSON.parse('{"key":"v-2d2a4ebc","path":"/note/golang/open-source-books/the-way-to-go/14/14.17.html","title":"14.17 通过通道并发访问对象","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"updatedTime":1684038853000},"readingTime":{"minutes":1.34,"words":403},"filePathRelative":"note/golang/open-source-books/the-way-to-go/14/14.17.md","excerpt":"<h1> 14.17 通过通道并发访问对象</h1>\\n<p>为了保护对象被并发访问修改，我们可以使用协程在后台顺序执行匿名函数来替代使用同步互斥锁。</p>\\n<p>在下面的程序中我们有一个类型 <code>Person</code> 中包含一个字段 <code>chF</code> ，这是一个用于存放匿名函数的通道。</p>\\n<p>这个结构在构造函数 <code>NewPerson()</code> 中初始化的同时会启动一个后台协程 <code>backend()</code>。<code>backend()</code> 方法会在一个无限循环中执行 <code>chF</code> 中放置的所有函数，有效地将它们序列化从而提供了安全的并发访问。更改和读取 <code>salary</code> 的方法会通过将一个匿名函数写入 <code>chF</code> 通道中，然后让 <code>backend()</code> 按顺序执行以达到其目的。需注意的是 <code>Salary()</code> 方法创建的闭包函数是如何将 <code>fChan</code> 通道包含在其中的。</p>"}');export{e as data};
