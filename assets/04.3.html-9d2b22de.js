import{_ as l,Z as i,$ as o,a0 as n,a1 as s,a2 as e,a3 as t,H as p}from"./framework-dee406ed.js";const c={},d=n("p",null,"双指针法解决链表问题有两种方式:",-1),r=n("ul",null,[n("li",null,"前后双指针: 一个指针提前向下个节点移动若干步, 然后再移动另一个指针 案例: 查找倒数第k个节点, 先让第一个指针移动k-1步, 之后和第二个(从头节点开始)一起移动. 当第一个指针到达尾节点时, 第二个指针刚好到达倒数第k个节点"),n("li",null,"快慢指针: 两个指针移动速度不同. 案例: 快指针一次移动两步, 慢指针一次移动一步; 当快指针到达末尾时, 慢指针指向中间节点.")],-1),u=n("h2",{id:"_4-3-1-问题21-删除倒数第k个节点",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_4-3-1-问题21-删除倒数第k个节点","aria-hidden":"true"},"#"),s(" 4.3.1 问题21: 删除倒数第k个节点")],-1),m={href:"https://leetcode.cn/problems/SLwz0R/",target:"_blank",rel:"noopener noreferrer"},v=t(`<blockquote><p>给定一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/remove_ex1.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：head = [1], n = 1
输出：[]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：head = [1,2], n = 1
输出：[1]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p>**进阶：**能尝试使用一趟扫描实现吗？</p></blockquote><h3 id="_4-3-1-1-分析" tabindex="-1"><a class="header-anchor" href="#_4-3-1-1-分析" aria-hidden="true">#</a> 4.3.1.1 分析</h3>`,2),k=n("p",null,[s("若要删除倒数第k个节点"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msub",null,[n("mi",null,"n"),n("mi",null,"k")])]),n("annotation",{encoding:"application/x-tex"},"n_k")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.3361em"}},[n("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k")])])]),n("span",{class:"vlist-s"},"​")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])])])])]),s(" , 只需找到倒数第k+1个节点然后将其指针指向倒数第k-1个节点即可.")],-1),b=n("p",null,"此时问题转化成了寻找倒数第k+1个节点, 使用前后双指针来解决:",-1),h=n("ol",null,[n("li",null,[s("前指针从头节点开始, 先移动"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mo",{stretchy:"false"},"("),n("mi",null,"k"),n("mo",null,"+"),n("mn",null,"1"),n("mo",{stretchy:"false"},")"),n("mo",null,"−"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"},"(k+1)-1")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},")"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"−"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1")])])]),s("即"),n("code",null,"k"),s("步")]),n("li",null,"后指针和前指针开始同步移动, 直到前指针到达尾节点"),n("li",null,"后指针指向倒数第k+1个节点, 将节点指针指向倒数第k-1个, 就删除了倒数第k个节点")],-1),g=t(`<p>只需遍历一次链表, 时间复杂度 O(n)</p><h3 id="_4-3-1-2-题解" tabindex="-1"><a class="header-anchor" href="#_4-3-1-2-题解" aria-hidden="true">#</a> 4.3.1.2 题解</h3><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>head <span class="token operator">*</span>ListNode<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>ListNode <span class="token punctuation">{</span>
    <span class="token comment">// 哨兵节点, 免去单独判断删除头节点的情况</span>
    dummy <span class="token operator">:=</span> <span class="token operator">&amp;</span>ListNode<span class="token punctuation">{</span><span class="token punctuation">}</span>
    dummy<span class="token punctuation">.</span>Next <span class="token operator">=</span> head

    <span class="token comment">// 前后双指针</span>
    front<span class="token punctuation">,</span> back <span class="token operator">:=</span> head<span class="token punctuation">,</span> dummy
    <span class="token comment">// 前指针移动 n 步</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
       front <span class="token operator">=</span> front<span class="token punctuation">.</span>Next
    <span class="token punctuation">}</span>

    <span class="token comment">// 移动双指针</span>
    <span class="token keyword">for</span> front <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
       front <span class="token operator">=</span> front<span class="token punctuation">.</span>Next
       back <span class="token operator">=</span> back<span class="token punctuation">.</span>Next
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除倒数第n个</span>
    back<span class="token punctuation">.</span>Next <span class="token operator">=</span> back<span class="token punctuation">.</span>Next<span class="token punctuation">.</span>Next
    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>Next
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-3-2-问题22-链表中环的入口节点" tabindex="-1"><a class="header-anchor" href="#_4-3-2-问题22-链表中环的入口节点" aria-hidden="true">#</a> 4.3.2 问题22: 链表中环的入口节点</h2>`,4),_={href:"https://leetcode.cn/problems/c32eOV/",target:"_blank",rel:"noopener noreferrer"},f=t(`<blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 <code>next</code> 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p><p>**说明：**不允许修改给定的链表。</p><p><strong>示例 1：</strong></p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/circularlinkedlist.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/circularlinkedlist_test2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/circularlinkedlist_test3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p>**进阶：**是否可以使用 <code>O(1)</code> 空间解决此题？</p></blockquote><h3 id="_4-3-2-1-分析" tabindex="-1"><a class="header-anchor" href="#_4-3-2-1-分析" aria-hidden="true">#</a> 4.3.2.1 分析</h3><p>使用快慢指针p1和p2:</p><ol><li>p1 每次走两步, p2每次走一步</li><li>若不存在环, 当p1走到尾节点时, 就会结束, 两者永远不会相遇</li><li>若存在环, 但两者相遇时, p1 走了2k步, p2 走了 k 步; 而两者相遇的节点 p3 一定在环内; 又因为 p1 p2 的步数之差 k, 一定是 p1 在环内循环的步数, 所以 k 为环内节点的整数倍</li><li>设定新指针 p4 从头节点开始, 然后 p3 和 p4 同步移动</li><li>当 p3 和 p4 相遇时, 就是环的入口节点</li></ol><h3 id="_4-3-2-2-题解" tabindex="-1"><a class="header-anchor" href="#_4-3-2-2-题解" aria-hidden="true">#</a> 4.3.2.2 题解</h3><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>head <span class="token operator">*</span>ListNode<span class="token punctuation">)</span> <span class="token operator">*</span>ListNode <span class="token punctuation">{</span>
	<span class="token comment">// 获取环中节点</span>
	inLoop <span class="token operator">:=</span> <span class="token function">getNodeInLoop</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span>
	<span class="token keyword">if</span> inLoop <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 前后指针</span>
	front <span class="token operator">:=</span> head
	<span class="token comment">// 相遇点即为环入口</span>
	<span class="token keyword">for</span> front <span class="token operator">!=</span> inLoop <span class="token punctuation">{</span>
		front <span class="token operator">=</span> front<span class="token punctuation">.</span>Next
		inLoop <span class="token operator">=</span> inLoop<span class="token punctuation">.</span>Next
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> front
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">getNodeInLoop</span><span class="token punctuation">(</span>head <span class="token operator">*</span>ListNode<span class="token punctuation">)</span> <span class="token operator">*</span>ListNode <span class="token punctuation">{</span>
	<span class="token comment">// 边界: 空链表或单节点</span>
	<span class="token keyword">if</span> head <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>Next <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 快慢指针</span>
	slow <span class="token operator">:=</span> head<span class="token punctuation">.</span>Next
	fast <span class="token operator">:=</span> slow<span class="token punctuation">.</span>Next <span class="token comment">// 步数为 slow 的两倍</span>
	<span class="token keyword">for</span> fast <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token comment">// 相遇点</span>
		<span class="token keyword">if</span> slow <span class="token operator">==</span> fast <span class="token punctuation">{</span>
			<span class="token keyword">return</span> slow
		<span class="token punctuation">}</span>
		<span class="token comment">// slow 走一步</span>
		slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>Next
		<span class="token comment">// fast 走两步</span>
		fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>Next
		<span class="token keyword">if</span> fast <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>Next
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-3-3-问题23-两个链表的第-i-个重合节点" tabindex="-1"><a class="header-anchor" href="#_4-3-3-问题23-两个链表的第-i-个重合节点" aria-hidden="true">#</a> 4.3.3 问题23: 两个链表的第 i 个重合节点</h2>`,7),x={href:"https://leetcode.cn/problems/3u1WK4/",target:"_blank",rel:"noopener noreferrer"},y=n("p",null,[s("给定两个单链表的头节点 "),n("code",null,"headA"),s(" 和 "),n("code",null,"headB"),s(" ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 "),n("code",null,"null"),s(" 。")],-1),w=n("p",null,[s("图示两个链表在节点 "),n("code",null,"c1"),s(" 开始相交**：**")],-1),N={href:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png",target:"_blank",rel:"noopener noreferrer"},L=n("img",{src:"https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/160_statement.png",alt:"img",tabindex:"0",loading:"lazy"},null,-1),B=n("figcaption",null,"img",-1),A=n("p",null,[s("题目数据 "),n("strong",null,"保证"),s(" 整个链式结构中不存在环。")],-1),z=n("p",null,[n("strong",null,"注意"),s("，函数返回结果后，链表必须 "),n("strong",null,"保持其原始结构"),s(" 。")],-1),V=n("p",null,[n("strong",null,"示例 1：")],-1),I={href:"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png",target:"_blank",rel:"noopener noreferrer"},M=n("img",{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png",alt:"img",tabindex:"0",loading:"lazy"},null,-1),O=n("figcaption",null,"img",-1),j=t(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at &#39;8&#39;
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p>`,2),q={href:"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png",target:"_blank",rel:"noopener noreferrer"},C=n("img",{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png",alt:"img",tabindex:"0",loading:"lazy"},null,-1),R=n("figcaption",null,"img",-1),E=t(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at &#39;2&#39;
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p>`,2),S={href:"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png",target:"_blank",rel:"noopener noreferrer"},F=n("img",{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png",alt:"img",tabindex:"0",loading:"lazy"},null,-1),H=n("figcaption",null,"img",-1),K=t(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>0 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li></ul><p>**进阶：**能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>`,4),T=n("h3",{id:"_4-3-3-1-分析",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_4-3-3-1-分析","aria-hidden":"true"},"#"),s(" 4.3.3.1 分析")],-1),W=n("p",null,[s("若使用暴力解法时间复杂度为 O("),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msup",null,[n("mi",null,"n"),n("mn",null,"2")])]),n("annotation",{encoding:"application/x-tex"},"n^2")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.8141em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])])])])]),s(").")],-1),Z=t(`<p>使用前后双指针的方式来解决:</p><ol><li>获取两个链表的长度差 d, O(m+n)</li><li>前后双指针 f, b; 长链表的指针 f 先移动 d 步</li><li>f, b 同步移动, 那么相遇的节点就是重合节点</li></ol><h3 id="_4-3-3-2-题解" tabindex="-1"><a class="header-anchor" href="#_4-3-3-2-题解" aria-hidden="true">#</a> 4.3.3.2 题解</h3><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>headA<span class="token punctuation">,</span> headB <span class="token operator">*</span>ListNode<span class="token punctuation">)</span> <span class="token operator">*</span>ListNode <span class="token punctuation">{</span>
    <span class="token comment">// 获取链表长度</span>
    lenA <span class="token operator">:=</span> <span class="token function">countList</span><span class="token punctuation">(</span>headA<span class="token punctuation">)</span>
    lenB <span class="token operator">:=</span> <span class="token function">countList</span><span class="token punctuation">(</span>headB<span class="token punctuation">)</span>

    <span class="token comment">// 前后双指针</span>
    longer<span class="token punctuation">,</span> shorter <span class="token operator">:=</span> <span class="token operator">&amp;</span>ListNode<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ListNode<span class="token punctuation">{</span><span class="token punctuation">}</span>
    delta <span class="token operator">:=</span> <span class="token number">0</span>
    <span class="token keyword">if</span> lenA <span class="token operator">&gt;</span> lenB <span class="token punctuation">{</span>
       longer <span class="token operator">=</span> headA
       shorter <span class="token operator">=</span> headB
       delta <span class="token operator">=</span> lenA <span class="token operator">-</span> lenB
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       longer <span class="token operator">=</span> headB
       shorter <span class="token operator">=</span> headA
       delta <span class="token operator">=</span> lenB <span class="token operator">-</span> lenA
    <span class="token punctuation">}</span>

    <span class="token comment">// 先移动前指针</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> delta<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
       longer <span class="token operator">=</span> longer<span class="token punctuation">.</span>Next
    <span class="token punctuation">}</span>
    <span class="token comment">// 同步移动</span>
    <span class="token keyword">for</span> longer <span class="token operator">!=</span> shorter <span class="token punctuation">{</span>
       longer <span class="token operator">=</span> longer<span class="token punctuation">.</span>Next
       shorter <span class="token operator">=</span> shorter<span class="token punctuation">.</span>Next
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> longer
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">countList</span><span class="token punctuation">(</span>head <span class="token operator">*</span>ListNode<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    count <span class="token operator">:=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> head <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
       head <span class="token operator">=</span> head<span class="token punctuation">.</span>Next
       count<span class="token operator">++</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> count
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2>`,5),$={href:"https://book.douban.com/subject/35543447/",target:"_blank",rel:"noopener noreferrer"};function D(G,J){const a=p("ExternalLinkIcon");return i(),o("div",null,[d,r,u,n("p",null,[n("a",m,[s("LCR 021. 删除链表的倒数第 N 个结点"),e(a)])]),v,k,b,h,g,n("p",null,[n("a",_,[s("LCR 022. 环形链表 II"),e(a)])]),f,n("p",null,[n("a",x,[s("LCR 023. 相交链表"),e(a)])]),n("blockquote",null,[y,w,n("figure",null,[n("a",N,[L,e(a)]),B]),A,z,V,n("figure",null,[n("a",I,[M,e(a)]),O]),j,n("figure",null,[n("a",q,[C,e(a)]),R]),E,n("figure",null,[n("a",S,[F,e(a)]),H]),K]),T,W,Z,n("ol",null,[n("li",null,[n("a",$,[s("剑指Offer（专项突破版）"),e(a)])])])])}const Q=l(c,[["render",D],["__file","04.3.html.vue"]]);export{Q as default};
