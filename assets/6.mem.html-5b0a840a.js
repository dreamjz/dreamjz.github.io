const l=JSON.parse('{"key":"v-f8c98220","path":"/interview/mysql/6.mem.html","title":"6. 内存","lang":"zh-CN","frontmatter":{"title":"6. 内存"},"headers":[{"level":2,"title":"6.1 Buffer Pool","slug":"_6-1-buffer-pool","link":"#_6-1-buffer-pool","children":[]},{"level":2,"title":"6.2 Buffer Pool 内容","slug":"_6-2-buffer-pool-内容","link":"#_6-2-buffer-pool-内容","children":[]},{"level":2,"title":"6.3 Buffer Pool 管理","slug":"_6-3-buffer-pool-管理","link":"#_6-3-buffer-pool-管理","children":[{"level":3,"title":"空闲页","slug":"空闲页","link":"#空闲页","children":[]},{"level":3,"title":"脏页","slug":"脏页","link":"#脏页","children":[]}]},{"level":2,"title":"6.4 缓存命中率","slug":"_6-4-缓存命中率","link":"#_6-4-缓存命中率","children":[{"level":3,"title":"LRU","slug":"lru","link":"#lru","children":[]},{"level":3,"title":"预读失效","slug":"预读失效","link":"#预读失效","children":[]},{"level":3,"title":"解决预读失效","slug":"解决预读失效","link":"#解决预读失效","children":[]},{"level":3,"title":"Buffer Pool 污染","slug":"buffer-pool-污染","link":"#buffer-pool-污染","children":[]},{"level":3,"title":"解决 Buffer Pool 污染","slug":"解决-buffer-pool-污染","link":"#解决-buffer-pool-污染","children":[]}]},{"level":2,"title":"6.5 脏页何时写入磁盘","slug":"_6-5-脏页何时写入磁盘","link":"#_6-5-脏页何时写入磁盘","children":[]},{"level":2,"title":"6.6 小结","slug":"_6-6-小结","link":"#_6-6-小结","children":[]}],"git":{"updatedTime":1698123705000},"readingTime":{"minutes":12.68,"words":3804},"filePathRelative":"interview/mysql/6.mem.md","excerpt":"<h2> 6.1 Buffer Pool</h2>\\n<p>Innodb 存储引擎设计了一个<strong>缓冲池（*Buffer Pool*）</strong>，来提高数据库的读写性能。</p>\\n<figure><img src=\\"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/缓冲池.drawio.png\\" alt=\\"img\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>img</figcaption></figure>\\n<p>有了缓冲池后：</p>\\n<ul>\\n<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>\\n<li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</li>\\n</ul>"}');export{l as data};
