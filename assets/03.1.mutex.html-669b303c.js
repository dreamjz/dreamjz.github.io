const e=JSON.parse('{"key":"v-f6665750","path":"/reading/golang/high-performance-go/03-concurrency/03.1.mutex.html","title":"3.1 互斥锁和读写锁的性能","lang":"zh-CN","frontmatter":{"title":"3.1 互斥锁和读写锁的性能","date":"2023-10-03T00:00:00.000Z","category":["golang"],"article":false},"headers":[{"level":2,"title":"1. 互斥锁和读写锁","slug":"_1-互斥锁和读写锁","link":"#_1-互斥锁和读写锁","children":[{"level":3,"title":"1.1 互斥锁(sync.Mutex)","slug":"_1-1-互斥锁-sync-mutex","link":"#_1-1-互斥锁-sync-mutex","children":[]},{"level":3,"title":"1.2 读写锁(sync.RWMutex)","slug":"_1-2-读写锁-sync-rwmutex","link":"#_1-2-读写锁-sync-rwmutex","children":[]}]},{"level":2,"title":"2. 性能比较","slug":"_2-性能比较","link":"#_2-性能比较","children":[{"level":3,"title":"2.1 测试用例","slug":"_2-1-测试用例","link":"#_2-1-测试用例","children":[]},{"level":3,"title":"2.2 Benchmark","slug":"_2-2-benchmark","link":"#_2-2-benchmark","children":[]},{"level":3,"title":"2.3 改变操作时间","slug":"_2-3-改变操作时间","link":"#_2-3-改变操作时间","children":[]}]},{"level":2,"title":"3. 互斥锁如何实现公平","slug":"_3-互斥锁如何实现公平","link":"#_3-互斥锁如何实现公平","children":[]},{"level":2,"title":"Reference","slug":"reference","link":"#reference","children":[]}],"git":{"updatedTime":1699943615000},"readingTime":{"minutes":4.49,"words":1347},"filePathRelative":"reading/golang/high-performance-go/03-concurrency/03.1.mutex.md","localizedDate":"2023年10月3日","excerpt":"<h2> 1. 互斥锁和读写锁</h2>\\n<h3> 1.1 互斥锁(sync.Mutex)</h3>\\n<p>互斥即不可同时运行。即使用了互斥锁的两个代码片段互相排斥，只有其中一个代码片段执行完成后，另一个才能执行。</p>\\n<p>Go 标准库中提供了 sync.Mutex 互斥锁类型及其两个方法：</p>\\n<ol>\\n<li>Lock 加锁</li>\\n<li>Unlock 释放锁</li>\\n</ol>\\n<p>通过在临界区前调用 Lock 方法，在代码后调用 Unlock 方法来保证一段代码的互斥执行，也可以用 defer 语句来保证互斥锁一定会被解锁。</p>\\n<p>在一个 Go 协程调用 Lock 方法获得锁后，其他请求锁的协程都会阻塞在 Lock 方法，直到锁被释放。</p>"}');export{e as data};
