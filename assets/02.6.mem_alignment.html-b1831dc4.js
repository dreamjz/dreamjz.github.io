import{_ as i,Z as o,$ as c,a0 as n,a1 as s,a2 as e,a3 as t,H as l}from"./framework-09afcf0b.js";const p={},u=t(`<h2 id="_1-获取变量占用的内存大小" tabindex="-1"><a class="header-anchor" href="#_1-获取变量占用的内存大小" aria-hidden="true">#</a> 1. 获取变量占用的内存大小</h2><p>Golang 中可以使用 <code>unsafe.Sizeof</code>获取变量的内存占用。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> Args <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    num1 <span class="token builtin">int</span>
    num2 <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Flag <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    num1 <span class="token builtin">int16</span>
    num2 <span class="token builtin">int32</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>Args<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>Flag<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// output</span>
<span class="token number">16</span>
<span class="token number">8</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>Args</code>：有两个 int 型字段，在 64 位系统中占用 8 Byte</li><li><code>Flag</code>：内存占用理论上是 4+2=6，结果为 8 Byte，多出的 2 Byte 是内存对齐的结果</li></ul><p>故一个变量的内存占用包含：</p><ol><li>各字段占用空间之和</li><li>内存对齐补充的空间</li></ol><h2 id="_2-内存对齐" tabindex="-1"><a class="header-anchor" href="#_2-内存对齐" aria-hidden="true">#</a> 2. 内存对齐</h2><h3 id="_2-1-为什么需要内存对齐" tabindex="-1"><a class="header-anchor" href="#_2-1-为什么需要内存对齐" aria-hidden="true">#</a> 2.1 为什么需要内存对齐</h3><p>CPU 访问内存时，不是逐个字节的访问，而是以字长(word size)为单位访问。如32位系统的字长为 4 字节。</p><p>采用字长可以减少 CPU 访问内存的次数，增大 CPU 访问内存的吞吐量。</p><p>若不进行内存对齐，会增大 CPU 的访问次数：</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310040659393.png" alt="memory alignment" tabindex="0" loading="lazy"><figcaption>memory alignment</figcaption></figure><p>由上图所示，a 和 b 各占用 3 字节，当CPU想要读取 b 的值时：</p><ol><li>若不进行内存对齐，需要读取两次，第一次获取 b 的第一个字节，第二次获取剩余的两个字节</li><li>若进行内存对齐，只需读取一次内存即可</li></ol><p>若变量的内存占用<strong>不超过字长</strong>时，在内存对齐的情况下，CPU 读取变量是<strong>原子性</strong>的。</p><h3 id="_2-2-unsafe-alignof" tabindex="-1"><a class="header-anchor" href="#_2-2-unsafe-alignof" aria-hidden="true">#</a> 2.2 unsafe.Alignof</h3><p><code>unsafe.Alignof</code>返回类型的<strong>对齐系数</strong>，那么此类型的变量占用的内存就必须是对齐系数的倍数。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>unsafe.Alignof(Args{}) // 8
unsafe.Alignof(Flag{}) // 4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>Args{}</code> 的对齐倍数是 8，<code>Args{}</code> 两个字段占据 16 字节，是 8 的倍数，无需占据额外的空间对齐。</li><li><code>Flag{}</code> 的对齐倍数是 4，因此 <code>Flag{}</code> 占据的空间必须是 4 的倍数，因此，6 内存对齐后是 8 字节。</li></ul><h3 id="_2-3-对齐保证-align-guarantee" tabindex="-1"><a class="header-anchor" href="#_2-3-对齐保证-align-guarantee" aria-hidden="true">#</a> 2.3 对齐保证(align guarantee)</h3>`,20),d={href:"https://golang.org/ref/spec#Size_and_alignment_guarantees",target:"_blank",rel:"noopener noreferrer"},r=n("code",null,"unsafe.Alignof",-1),k=t(`<blockquote><ol><li>For a variable x of any type: unsafe.Alignof(x) is at least 1.</li><li>For a variable x of struct type: unsafe.Alignof(x) is the largest of all the values unsafe.Alignof(x.f) for each field f of x, but at least 1.</li><li>For a variable x of array type: unsafe.Alignof(x) is the same as the alignment of a variable of the array’s element type.</li></ol></blockquote><ul><li>对于任意类型的变量 x ，<code>unsafe.Alignof(x)</code> 至少为 1。</li><li>对于 struct 结构体类型的变量 x，计算 x 每一个字段 f 的 <code>unsafe.Alignof(x.f)</code>，<code>unsafe.Alignof(x)</code> 等于其中的最大值。</li><li>对于 array 数组类型的变量 x，<code>unsafe.Alignof(x)</code> 等于构成数组的元素类型的对齐倍数。</li></ul><blockquote><p>A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.</p></blockquote><p>没有任何字段的空 struct{} 和没有任何元素的 array 占据的内存空间大小为 0，不同的大小为 0 的变量可能指向同一块地址。</p><h2 id="_3-内存对齐技巧" tabindex="-1"><a class="header-anchor" href="#_3-内存对齐技巧" aria-hidden="true">#</a> 3. 内存对齐技巧</h2><h3 id="_3-1-合理布局减少内存占用" tabindex="-1"><a class="header-anchor" href="#_3-1-合理布局减少内存占用" aria-hidden="true">#</a> 3.1 合理布局减少内存占用</h3><p>假设一个 struct 包含三个字段，<code>a int8</code>、<code>b int16</code>、<code>c int64</code>：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> demo1 <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	a <span class="token builtin">int8</span>
	b <span class="token builtin">int16</span>
	c <span class="token builtin">int32</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> demo2 <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	a <span class="token builtin">int8</span>
	c <span class="token builtin">int32</span>
	b <span class="token builtin">int16</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>demo1<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 8</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>demo2<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 12</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出结构体中的字段顺序会对结构整体的内存占用产生影响。</p><p>每个字段会根据自己的<strong>对齐系数</strong>来计算内存中的偏移量，字段排列顺序不同，前一个字段因偏移而浪费的内存大小不同。</p><p>对于 <code>demo1</code>，结构体的对齐系数会是字段中<strong>最大</strong>的那个 ：</p><ul><li><code>a int8</code>，对齐系数为 1，已对齐</li><li><code>b int16</code>，对齐系数为 2，整体占用 3 = 1+2，需要空出一个字节进行对齐</li><li><code>c int32</code>，对齐系数为 4，整体占用 8= 1+1+2+4，已对齐</li></ul><p>对于<code>demo2</code>：</p><ul><li><code>a int8</code>：对齐系数为 1，已对齐</li><li><code>b int32</code>：对齐系数为 4，整体占用 5 = 1+4，需空出 3 个字节进行对齐</li><li><code>c int16</code>：对齐系数为 2，结构体对齐系数为 4，整体占用 10 = 1+3+4+2，需空出 2 个字节进行对齐</li></ul><p><code>demo2</code>对齐后的内存占用为：12 = 1+3+4+2+2</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310040726877.png" alt="memory alignment" tabindex="0" loading="lazy"><figcaption>memory alignment</figcaption></figure><p>因此在内存敏感的结构体设计上，可以通过调整字段顺序，减少内存占用。</p><h3 id="_3-2-空结构体的内存对齐" tabindex="-1"><a class="header-anchor" href="#_3-2-空结构体的内存对齐" aria-hidden="true">#</a> 3.2 空结构体的内存对齐</h3><p>空<code>struct{}</code>大小为 0，作为 struct 的字段时，一般无需对齐。</p><p>但是若 <code>struct{}</code>作为<strong>最后一个字段</strong>时，需要进行<strong>内存对齐</strong>。因为如果有指针指向该字段，返回的地址将会在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> demo3 <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	c <span class="token builtin">int32</span>
	a <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> demo4 <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	a <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
	c <span class="token builtin">int32</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>demo3<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 8</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>demo4<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 4</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>demo3</code>中：</p><ul><li><code>c int32</code>：对齐系数为 4，整体系数为 4 ，占用 4 B，无需对齐</li><li><code>a struct{}</code>：虽然内存占用为0，但是需要额外的内存对齐，对齐 4 字节</li></ul><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2>`,24),m={href:"https://geektutu.com/post/hpg-struct-alignment.html",target:"_blank",rel:"noopener noreferrer"},v={href:"https://stackoverflow.com/questions/381244/purpose-of-memory-alignment",target:"_blank",rel:"noopener noreferrer"};function f(g,b){const a=l("ExternalLinkIcon");return o(),c("div",null,[u,n("p",null,[s("Golang 官方文档 "),n("a",d,[s("Size and alignment guarantees - golang spec"),e(a)]),s(" 描述了函数"),r,s(" 的规则：")]),k,n("ol",null,[n("li",null,[n("a",m,[s("https://geektutu.com/post/hpg-struct-alignment.html"),e(a)])]),n("li",null,[n("a",v,[s("Purpose of memory alignment"),e(a)])])])])}const _=i(p,[["render",f],["__file","02.6.mem_alignment.html.vue"]]);export{_ as default};
