import{_ as p,Z as o,$ as c,a0 as n,a1 as s,a2 as e,a4 as t,H as i}from"./framework-d03928c9.js";const l={},u={href:"https://en.wikipedia.org/wiki/Computer_science",target:"_blank",rel:"noopener noreferrer"},r=n("strong",null,"topological sort",-1),d=n("strong",null,"topological ordering",-1),k={href:"https://en.wikipedia.org/wiki/Directed_graph",target:"_blank",rel:"noopener noreferrer"},v={href:"https://en.wikipedia.org/wiki/Total_order",target:"_blank",rel:"noopener noreferrer"},m={href:"https://en.wikipedia.org/wiki/Vertex_(graph_theory)",target:"_blank",rel:"noopener noreferrer"},b=n("em",null,"uv",-1),g=n("em",null,"u",-1),h=n("em",null,"v",-1),f=n("em",null,"u",-1),q=n("em",null,"v",-1),_=n("p",null,"For instance, the vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another; in this application, a topological ordering is just a valid sequence for the tasks.",-1),x=t(`<p>拓扑排序是指对一个<strong>有向无环</strong>图的节点进行排序之后得到的序列.</p><p>若存在一条从A到B的边, 那么在拓扑排序中A一定在B的前面.</p><p>一个<strong>有向无环图</strong>有<strong>一个或多个</strong>拓扑排序序列, <strong>无向图</strong>或<strong>有向有环</strong>图<strong>不存在</strong>拓扑排序序列.</p><h2 id="_15-3-1-kahn-s-algorithm" tabindex="-1"><a class="header-anchor" href="#_15-3-1-kahn-s-algorithm" aria-hidden="true">#</a> 15.3.1 Kahn&#39;s algorithm</h2><p>入度: 节点v的入度是以v为<strong>终点</strong>的边的数目.</p><p>出度: 节点v的出度是以v为<strong>起点</strong>的边的数目.</p><p>流程:</p><ol><li>取出一个入度为0的节点, 放入拓扑排序序列;</li><li>删除该节点以及所有以它为起点的边; 继续步骤 1) 直到图为空或不存在入度为0的节点.</li></ol><p>若图<strong>为空</strong>则找到了<strong>拓扑排序</strong>序列.</p><p>若图<strong>不为空</strong>并且<strong>不存在入度为0</strong>的节点, 那么图一定<strong>有环</strong>.</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>L ← Empty list that will contain the sorted elements
S ← Set of all nodes with no incoming edge

while S is not empty do
    remove a node n from S
    add n to L
    for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S

if graph has edges then
    return error   (graph has at least one cycle)
else 
    return L   (a topologically sorted order)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此算法可以寻找拓扑排序或者判断是否有环.</p><h2 id="_15-3-2-问题113-课程排序" tabindex="-1"><a class="header-anchor" href="#_15-3-2-问题113-课程排序" aria-hidden="true">#</a> 15.3.2 问题113: 课程排序</h2>`,13),w={href:"https://leetcode.cn/problems/QA2IGt/",target:"_blank",rel:"noopener noreferrer"},y=t(`<blockquote><p>现在总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses-1</code>。</p><p>给定一个数组 <code>prerequisites</code> ，它的每一个元素 <code>prerequisites[i]</code> 表示两门课程之间的先修顺序。 例如 <code>prerequisites[i] = [ai, bi]</code> 表示想要学习课程 <code>ai</code> ，需要先完成课程 <code>bi</code> 。</p><p>请根据给出的总课程数 <code>numCourses</code> 和表示先修顺序的 <code>prerequisites</code> 得出一个可行的修课序列。</p><p>可能会有多个正确的顺序，只要任意返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><p><strong>示例 1:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: numCourses = 2, prerequisites = [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: numCourses = 1, prerequisites = [] 
输出: [0]
解释: 总共 1 门课，直接修第一门课就可。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>ai != bi</code></li><li><code>prerequisites</code> 中不存在重复元素</li></ul></blockquote><h3 id="_15-3-2-1-分析-题解" tabindex="-1"><a class="header-anchor" href="#_15-3-2-1-分析-题解" aria-hidden="true">#</a> 15.3.2.1 分析&amp;题解</h3><p>将课程当作节点, 课程先后顺序左右边, 构建有向图.</p><p>例如: <code>numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</code></p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/image-20230917234652608.png" alt="image-20230917234652608" tabindex="0" loading="lazy"><figcaption>image-20230917234652608</figcaption></figure><p>课程的顺序实际就是图的拓扑排序序列, 问题就变成了求有向图的拓扑排序序列.</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">findOrder</span><span class="token punctuation">(</span>numCourses <span class="token builtin">int</span><span class="token punctuation">,</span> prerequisites <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token comment">// 构建有向图</span>
    graph <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> numCourses<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s
    <span class="token punctuation">}</span>
    <span class="token comment">// 邻接表</span>
    inDegrees <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> numCourses<span class="token punctuation">)</span> <span class="token comment">// 节点入度</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> pre <span class="token operator">:=</span> <span class="token keyword">range</span> prerequisites <span class="token punctuation">{</span> 
        graph<span class="token punctuation">[</span>pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>graph<span class="token punctuation">[</span>pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        inDegrees<span class="token punctuation">[</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 广度优先搜索入度为0的节点</span>
    queue <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> d <span class="token operator">:=</span> <span class="token keyword">range</span> inDegrees <span class="token punctuation">{</span>
        <span class="token keyword">if</span> d <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            queue <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 拓扑排序序列</span>
    res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> numCourses<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        cur <span class="token operator">:=</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        queue <span class="token operator">=</span> queue<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>

        <span class="token comment">// 加入拓扑排序序列</span>
        res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cur<span class="token punctuation">)</span>
        <span class="token comment">// 删除以 cur 为起点的边</span>
        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> adj <span class="token operator">:=</span> <span class="token keyword">range</span> graph<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token punctuation">{</span>
            inDegrees<span class="token punctuation">[</span>adj<span class="token punctuation">]</span><span class="token operator">--</span>
            <span class="token comment">// 添加新的入度为 0 的节点</span>
            <span class="token keyword">if</span> inDegrees<span class="token punctuation">[</span>adj<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
                queue <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> adj<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">==</span> numCourses <span class="token punctuation">{</span>
        <span class="token keyword">return</span> res
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_15-3-3-问题114-外星文字典" tabindex="-1"><a class="header-anchor" href="#_15-3-3-问题114-外星文字典" aria-hidden="true">#</a> 15.3.3 问题114: 外星文字典</h2>`,8),C={href:"https://leetcode.cn/problems/Jf1JuT/",target:"_blank",rel:"noopener noreferrer"},D=t(`<blockquote><p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p><p>给定一个字符串列表 <code>words</code> ，作为这门语言的词典，<code>words</code> 中的字符串已经 <strong>按这门新语言的字母顺序进行了排序</strong> 。</p><p>请你根据该词典还原出此语言中已知的字母顺序，并 <strong>按字母递增顺序</strong> 排列。若不存在合法字母顺序，返回 <code>&quot;&quot;</code> 。若存在多种可能的合法字母顺序，返回其中 <strong>任意一种</strong> 顺序即可。</p><p>字符串 <code>s</code> <strong>字典顺序小于</strong> 字符串 <code>t</code> 有两种情况：</p><ul><li>在第一个不同字母处，如果 <code>s</code> 中的字母在这门外星语言的字母顺序中位于 <code>t</code> 中字母之前，那么 <code>s</code> 的字典顺序小于 <code>t</code> 。</li><li>如果前面 <code>min(s.length, t.length)</code> 字母都相同，那么 <code>s.length &lt; t.length</code> 时，<code>s</code> 的字典顺序也小于 <code>t</code> 。</li></ul><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：words = [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]
输出：&quot;wertf&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：words = [&quot;z&quot;,&quot;x&quot;]
输出：&quot;zx&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：words = [&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]
输出：&quot;&quot;
解释：不存在合法字母顺序，因此返回 &quot;&quot; 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 100</code></li><li><code>words[i]</code> 仅由小写英文字母组成</li></ul></blockquote><h3 id="_15-3-3-1-分析-题解" tabindex="-1"><a class="header-anchor" href="#_15-3-3-1-分析-题解" aria-hidden="true">#</a> 15.3.3.1 分析&amp;题解</h3><p>// TODO: 2023-09-18</p><h2 id="_15-3-4-问题115-重建序列" tabindex="-1"><a class="header-anchor" href="#_15-3-4-问题115-重建序列" aria-hidden="true">#</a> 15.3.4 问题115: 重建序列</h2>`,4),j={href:"https://leetcode.cn/problems/ur2n8P/",target:"_blank",rel:"noopener noreferrer"},z=t(`<blockquote><p>给定一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 是范围为 <code>[1，n]</code> 的整数的排列。还提供了一个 2D 整数数组 <code>sequences</code> ，其中 <code>sequences[i]</code> 是 <code>nums</code> 的子序列。 检查 <code>nums</code> 是否是唯一的最短 <strong>超序列</strong> 。最短 <strong>超序列</strong> 是 <strong>长度最短</strong> 的序列，并且所有序列 <code>sequences[i]</code> 都是它的子序列。对于给定的数组 <code>sequences</code> ，可能存在多个有效的 <strong>超序列</strong> 。</p><ul><li>例如，对于 <code>sequences = [[1,2],[1,3]]</code> ，有两个最短的 <strong>超序列</strong> ，<code>[1,2,3]</code> 和 <code>[1,3,2]</code> 。</li><li>而对于 <code>sequences = [[1,2],[1,3],[1,2,3]]</code> ，唯一可能的最短 <strong>超序列</strong> 是 <code>[1,2,3]</code> 。<code>[1,2,3,4]</code> 是可能的超序列，但不是最短的。</li></ul><p><em>如果 <code>nums</code> 是序列的唯一最短 <strong>超序列</strong> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</em><strong>子序列</strong> 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。</p><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：nums = [1,2,3], sequences = [[1,2],[1,3]]
输出：false
解释：有两种可能的超序列：[1,2,3]和[1,3,2]。
序列 [1,2] 是[1,2,3]和[1,3,2]的子序列。
序列 [1,3] 是[1,2,3]和[1,3,2]的子序列。
因为 nums 不是唯一最短的超序列，所以返回false。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：nums = [1,2,3], sequences = [[1,2]]
输出：false
解释：最短可能的超序列为 [1,2]。
序列 [1,2] 是它的子序列：[1,2]。
因为 nums 不是最短的超序列，所以返回false。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]
输出：true
解释：最短可能的超序列为[1,2,3]。
序列 [1,2] 是它的一个子序列：[1,2,3]。
序列 [1,3] 是它的一个子序列：[1,2,3]。
序列 [2,3] 是它的一个子序列：[1,2,3]。
因为 nums 是唯一最短的超序列，所以返回true。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>nums</code> 是 <code>[1, n]</code> 范围内所有整数的排列</li><li><code>1 &lt;= sequences.length &lt;= 10^4</code></li><li><code>1 &lt;= sequences[i].length &lt;= 10^4</code></li><li><code>1 &lt;= sum(sequences[i].length) &lt;= 10^5</code></li><li><code>1 &lt;= sequences[i][j] &lt;= n</code></li><li><code>sequences</code> 的所有数组都是 <strong>唯一</strong> 的</li><li><code>sequences[i]</code> 是 <code>nums</code> 的一个子序列</li></ul></blockquote><h3 id="_15-3-4-1-分析-题解" tabindex="-1"><a class="header-anchor" href="#_15-3-4-1-分析-题解" aria-hidden="true">#</a> 15.3.4.1 分析&amp;题解</h3><p>超序列和子序列是两个相对的概念.若序列A中的所有元素按照先后顺序在B中出现, 那么A是B的子序列, B是A的超序列.</p><p>将seqs中的所有数字看成节点, 相邻的数字有一条前面数字指向后面的边, 构成一个有向图.</p><p>以<code>nums = [1,2,3], sequences = [[1,2],[1,3]]</code> 为例:</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/image-20230918005032250.png" alt="image-20230918005032250" tabindex="0" loading="lazy"><figcaption>image-20230918005032250</figcaption></figure><p>由seqs重建的序列为图的拓扑排序序列, 那么问题就变成了, 拓扑排序序列是否唯一并且为 <code>nums</code>.</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">sequenceReconstruction</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> sequences <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token comment">// 构建有向图</span>
	inDegrees <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 入度</span>
	graph <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> seq <span class="token operator">:=</span> <span class="token keyword">range</span> sequences <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> graph<span class="token punctuation">[</span>seq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
				s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
				graph<span class="token punctuation">[</span>seq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> s
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> inDegrees<span class="token punctuation">[</span>seq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
				inDegrees<span class="token punctuation">[</span>seq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> graph<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
				s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
				graph<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> s
			<span class="token punctuation">}</span>
			graph<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>graph<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token comment">// 入度增加</span>
			<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> inDegrees<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
				inDegrees<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
			<span class="token punctuation">}</span>
			inDegrees<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 入度为0的节点</span>
	queue <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> inDegrees <span class="token punctuation">{</span>
		<span class="token keyword">if</span> v <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			queue <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 拓扑排序序列</span>
	res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">// 寻找唯一拓扑排序序列</span>
	<span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		cur <span class="token operator">:=</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
		queue <span class="token operator">=</span> queue<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
		<span class="token comment">// 添加至拓扑序列</span>
		res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cur<span class="token punctuation">)</span>

		<span class="token comment">// 删除边</span>
		<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> adj <span class="token operator">:=</span> <span class="token keyword">range</span> graph<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token punctuation">{</span>
			inDegrees<span class="token punctuation">[</span>adj<span class="token punctuation">]</span><span class="token operator">--</span>
			<span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> inDegrees<span class="token punctuation">[</span>adj<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> v <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				queue <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> adj<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> reflect<span class="token punctuation">.</span><span class="token function">DeepEqual</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2>`,9),B={href:"https://book.douban.com/subject/35543447/",target:"_blank",rel:"noopener noreferrer"},L={href:"https://en.wikipedia.org/wiki/Topological_sorting",target:"_blank",rel:"noopener noreferrer"};function A(I,S){const a=i("ExternalLinkIcon");return o(),c("div",null,[n("blockquote",null,[n("p",null,[s("In "),n("a",u,[s("computer science"),e(a)]),s(", a "),r,s(" or "),d,s(" of a "),n("a",k,[s("directed graph"),e(a)]),s(" is a "),n("a",v,[s("linear ordering"),e(a)]),s(" of its "),n("a",m,[s("vertices"),e(a)]),s(" such that for every directed edge "),b,s(" from vertex "),g,s(" to vertex "),h,s(", "),f,s(" comes before "),q,s(" in the ordering.")]),_]),x,n("p",null,[n("a",w,[s("LCR 113. 课程表 II"),e(a)])]),y,n("p",null,[n("a",C,[s("LCR 114. 火星词典"),e(a)])]),D,n("p",null,[n("a",j,[s("LCR 115. 序列重建"),e(a)])]),z,n("ol",null,[n("li",null,[n("a",B,[s("剑指Offer（专项突破版）"),e(a)])]),n("li",null,[n("a",L,[s("https://en.wikipedia.org/wiki/Topological_sorting"),e(a)])])])])}const E=p(l,[["render",A],["__file","15.3.html.vue"]]);export{E as default};
