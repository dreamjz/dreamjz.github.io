const e=JSON.parse('{"key":"v-a16d7c42","path":"/reading/golang/7-days-golang/02-GeeCache-DitributedCache/02.0.preface.html","title":"0. 分布式缓存","lang":"zh-CN","frontmatter":{"title":"0. 分布式缓存","date":"2023-10-10T00:00:00.000Z","category":["golang"]},"headers":[{"level":2,"title":"1. 分布式缓存","slug":"_1-分布式缓存","link":"#_1-分布式缓存","children":[{"level":3,"title":"1.1 键值对缓存","slug":"_1-1-键值对缓存","link":"#_1-1-键值对缓存","children":[]}]},{"level":2,"title":"2. 分布式缓存系统","slug":"_2-分布式缓存系统","link":"#_2-分布式缓存系统","children":[]},{"level":2,"title":"Reference","slug":"reference","link":"#reference","children":[]}],"readingTime":{"minutes":0.84,"words":252},"filePathRelative":"reading/golang/7-days-golang/02-GeeCache-DitributedCache/02.0.preface.md","localizedDate":"2023年10月10日","excerpt":"<h2> 1. 分布式缓存</h2>\\n<p>缓存的设计随处可见，例如：</p>\\n<ul>\\n<li>浏览器缓存，访问网页时会优先从缓存中读取</li>\\n<li>I/O 缓存，计算机写入数据到硬盘时，会先缓存到内存中然后一次写入</li>\\n<li>Redis 缓存，对即时性要求较高的某些数据会缓存在 Redis 集群之中</li>\\n<li>...</li>\\n</ul>\\n<h3> 1.1 键值对缓存</h3>\\n<p>使用哈希表实现键值对缓存是最简单的实现方式，但是存在一些问题：</p>\\n<ol>\\n<li>淘汰策略\\n当内存不够时，需要删除数据，需要一个淘汰策略来合理的删除一些数据</li>\\n<li>并发冲突\\n<code>map</code>不是并发安全的，需要额外的加锁</li>\\n<li>单机性能\\n单机性能是有瓶颈的，此时需要考虑分布式系统</li>\\n<li>...</li>\\n</ol>"}');export{e as data};
