import{_ as i,Z as a,$ as e,a3 as r}from"./framework-dee406ed.js";const t={},n=r('<h2 id="_1-1-计算机网络体系结构" tabindex="-1"><a class="header-anchor" href="#_1-1-计算机网络体系结构" aria-hidden="true">#</a> 1.1 计算机网络体系结构</h2><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310182244994.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_1-2-osi-模型" tabindex="-1"><a class="header-anchor" href="#_1-2-osi-模型" aria-hidden="true">#</a> 1.2 OSI 模型</h2><p>开放式系统互联模型（Open System Interconnection Model，简称为 OSI 模型）是一种概念模型，由国际标准化组织提出，并试图成为计算机在世界范围内互连为网络的标准框架，它具有七层网络结构。</p><h2 id="_1-3-五层模型" tabindex="-1"><a class="header-anchor" href="#_1-3-五层模型" aria-hidden="true">#</a> 1.3 五层模型</h2><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。 传输层包括两种协议： <ul><li>传输控制协议 <strong>TCP</strong>，提供面向连接、可靠的数据传输服务，数据单位为报文段；</li><li>用户数据报协议 <strong>UDP</strong>，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li></ul></li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h2 id="_1-4-tcp-ip-模型" tabindex="-1"><a class="header-anchor" href="#_1-4-tcp-ip-模型" aria-hidden="true">#</a> 1.4 TCP/IP 模型</h2><h3 id="应用层" tabindex="-1"><a class="header-anchor" href="#应用层" aria-hidden="true">#</a> 应用层</h3><ul><li>为用户提供应用功能；如 HTTP、FTP、Telnet等</li><li>工作于操作系统的用户态</li></ul><h3 id="传输层" tabindex="-1"><a class="header-anchor" href="#传输层" aria-hidden="true">#</a> 传输层</h3><p>传输层包含两个协议：</p><ol><li>TCP (Transmission Control Protocol，传输控制协议)</li><li>UDP (User Datagram Protocol，用户数据报协议 )</li></ol><p>端口：用于识别和区分数据发送的目标</p><h3 id="网络层" tabindex="-1"><a class="header-anchor" href="#网络层" aria-hidden="true">#</a> 网络层</h3><p>网络层主要包含两个协议：</p><ol><li>ARP协议；用于映射 IP 和 MAC 地址</li><li>IP 协议</li></ol><p>IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191015831.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>IP 地址分为：</p><ul><li>网络号，标识 IP 地址属于哪个子网</li><li>主机号，标识子网中的主机</li></ul><p>网络号和主机号通过<strong>子网掩码</strong>计算，子网掩码可用 IP 格式或用1的位数标表示（如：<code>255.255.255.0</code>或 <code>/24</code>）：</p><ul><li>网络号，IP 地址和掩码按位与得到；如：<code>10.100.122.2 &amp; 255.255.255.0 = 10.100.120.0</code></li><li>主机号，IP 地址和掩码取反后按位与；如：<code>10.100.122.2 &amp; 0.0.0.255 = 0.0.0.2</code></li></ul><h4 id="ip-路由寻址" tabindex="-1"><a class="header-anchor" href="#ip-路由寻址" aria-hidden="true">#</a> IP 路由寻址</h4><p>路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191023775.png" alt="IP地址的网络号" tabindex="0" loading="lazy"><figcaption>IP地址的网络号</figcaption></figure><h3 id="网络接口层" tabindex="-1"><a class="header-anchor" href="#网络接口层" aria-hidden="true">#</a> 网络接口层</h3><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，可以通过 ARP 协议获取对方的 MAC 地址。</p><p>网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备</p><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p>TCP/IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191026868.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>每层报文封装格式：</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191026837.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>网络接口层的传输单位是 帧(frame)</li><li>IP 层的传输单位是 包(packet)</li><li>TCP 传输单位是 段(segment)</li><li>HTTP 传输单位是 报文(message)</li></ul><h2 id="_1-5-浏览器键入网址到显示网页期间发生了什么" tabindex="-1"><a class="header-anchor" href="#_1-5-浏览器键入网址到显示网页期间发生了什么" aria-hidden="true">#</a> 1.5 浏览器键入网址到显示网页期间发生了什么</h2><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191030743.png" alt="简单的网络模型" tabindex="0" loading="lazy"><figcaption>简单的网络模型</figcaption></figure><h3 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h3><p><strong>第一步，解析 URL</strong></p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191032577.jpeg" alt="URL 解析" tabindex="0" loading="lazy"><figcaption>URL 解析</figcaption></figure><p><strong>第二步，生成 HTTP 请求</strong></p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191033620.png" alt="HTTP 的消息格式" tabindex="0" loading="lazy"><figcaption>HTTP 的消息格式</figcaption></figure><h3 id="dns" tabindex="-1"><a class="header-anchor" href="#dns" aria-hidden="true">#</a> DNS</h3><p><strong>第三步，查询服务器 IP 地址</strong></p><p>通过域名访问 DNS 服务器解析出 IP 地址。</p><p>DNS 层级关系如下：</p><ul><li>根 DNS 服务器(.)</li><li>顶级域名 DNS 服务器</li><li>权威 DNS 服务器</li></ul><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191036242.png" alt="DNS 树状结构" tabindex="0" loading="lazy"><figcaption>DNS 树状结构</figcaption></figure><h4 id="域名解析流程" tabindex="-1"><a class="header-anchor" href="#域名解析流程" aria-hidden="true">#</a> 域名解析流程</h4><ol><li>客户端发送 DNS 请求给本地 DNS 服务器（本地网络设置的 DNS 服务器地址）</li><li>本地DNS服务器若存在缓存则直接返回；若没有则访问根 DNS 服务器</li><li>根DNS服务器根据域名返回顶级域名DNS服务器的<strong>地址</strong></li><li>本地DNS服务器访问顶级域名DNS服务器，获取权威域名DNS服务器<strong>地址</strong></li><li>本地DNS服务器访问权威域名DNS服务器，获取域名对应的 IP 地址</li><li>将 IP 地址返回给客户端</li></ol><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191041966.png" alt="域名解析的工作流程" tabindex="0" loading="lazy"><figcaption>域名解析的工作流程</figcaption></figure><h4 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h4><p>解析域名，无需每次经过完整流程，会优先在缓存中寻找：</p><ol><li>浏览器缓存</li><li>操作系统缓存，即 HOSTS 文件</li><li>DNS 服务器自身的缓存</li></ol><h3 id="协议栈" tabindex="-1"><a class="header-anchor" href="#协议栈" aria-hidden="true">#</a> 协议栈</h3><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191054190.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p><ul><li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><h3 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h3><p><strong>第四步，决定传输协议 TCP</strong></p><p>HTTP 是基于 TCP 协议的，所以采用 TCP 进行传输。</p><h4 id="tcp-报文头" tabindex="-1"><a class="header-anchor" href="#tcp-报文头" aria-hidden="true">#</a> TCP 报文头</h4><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191100557.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>源端口号</strong>和<strong>目标端口</strong>号：用于表示发送源和发送目标</li><li>序号：用于解决包乱序的问题，接收方会在缓存区中按照序号排序</li><li>确认号：用于确认接收方是否收到，若未收到的重新发送，用于解决丢包问题</li><li><strong>数据偏移</strong>：占 4 位，其所能表达的最大数字是 15 。数据偏移表示该数据报中数据的起始位置，由于数据报是由 首部+数据 组成，所以实际上就是指报文段的首部长度。数据偏移的单位是 32 位字（即以 4 字节长为单位），所以数据偏移的最大长度是 60 （15*4）字节，即 TCP 报文段的首部长度不能超过 60 字节，对应的选项长度不能超过 40 字节。</li><li><strong>保留</strong>：占 6 位，保留为今后使用，目前应置为 0</li><li><strong>控制位</strong>： <ul><li><strong>紧急 URG (URGent)</strong>：当值为 1 时，表明紧急指针字段有效，代表此报文中有紧急数据，应尽快传送，而无需按原来的排队顺序传送。</li><li><strong>确认 ACK (ACKnowledgment)</strong>：当值为 1 时，确认号有效；值为 0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</li><li><strong>推送 PSH (Push)</strong>：当值为 1 时，表示接受方应该将数据立即交付给应用进程，而不是等待缓存填满后再向上交付。</li><li><strong>复位 RST (Reset)</strong>：当值为 1 时，表明 TCP 连接出现严重差错，必须立即释放，然后再重新建立连接；也可以用来拒绝一个非法的报文段或拒绝打开一个连接。</li><li><strong>同步 SYN (SYNchronization)</strong>：在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段；对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1 。</li><li><strong>终止 FIN (FINis)</strong>：当值为 1 时，表明此报文段发送方的数据已发送完毕，并要求释放连接。</li></ul></li><li><strong>窗口</strong>：占 2 字节，取值范围为 [ 0 , 216 - 1 ] 之间的整数。窗口字段保持动态变化，用于指明接收方允许发送方发送的数据量。</li><li><strong>校验和</strong>：占 2 字节，校验的字段范围包括首部和数据</li><li><strong>紧急指针</strong>：占 2 字节，仅在 URG = 1 时才有意义，用于指明紧急数据的结束位置，位于结束位置之后的就是普通数据</li><li><strong>选项</strong>：长度可变，最长可达 40 字节。可用的选项有：最大报文段长度 ，窗口扩大选项、时间戳选项等</li></ul><h4 id="建立连接-三次握手" tabindex="-1"><a class="header-anchor" href="#建立连接-三次握手" aria-hidden="true">#</a> 建立连接-三次握手</h4><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191106346.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>服务器主动监听端口，进入 LISTEN 状态</li><li>客户端发起连接，同步位<code>SYN = 1</code>，选择初始序列号<code>seq = x</code>，进入<code>SYN-SENT</code>同步已发送状态</li><li>服务端若同意接收请求，则发送确认报文，同步位和确认位置 1(<code>SYN = 1, ACK = 1</code>)，确认号<code>ack = x + 1</code>，选择初始序列号<code>seq = y</code>，进入 <code>SYN-RCVD</code>同步已接收状态</li><li>客户端收到报文后，发送确认报文，确认位 <code>ACK = 1</code>，确认号<code>ack = y + 1</code>，序列号<code>seq = x + 1</code>。进入已连接状态<code>ESTABLISHED</code></li><li>服务端收到报文，进入已连接状态<code>ESTABLISHED</code></li></ol><h4 id="三次握手的目的" tabindex="-1"><a class="header-anchor" href="#三次握手的目的" aria-hidden="true">#</a> 三次握手的目的</h4><p>用于确认双方的报文<strong>收发功能</strong>正常。</p><h4 id="数据分割" tabindex="-1"><a class="header-anchor" href="#数据分割" aria-hidden="true">#</a> 数据分割</h4><p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191113402.png" alt="MTU 与 MSS" tabindex="0" loading="lazy"><figcaption>MTU 与 MSS</figcaption></figure><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p>数据会被以 <code>MSS</code> 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191113136.png" alt="数据包分割" tabindex="0" loading="lazy"><figcaption>数据包分割</figcaption></figure><h4 id="生成-tcp-报文" tabindex="-1"><a class="header-anchor" href="#生成-tcp-报文" aria-hidden="true">#</a> 生成 TCP 报文</h4><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191114722.png" alt="TCP 层报文" tabindex="0" loading="lazy"><figcaption>TCP 层报文</figcaption></figure><h3 id="ip" tabindex="-1"><a class="header-anchor" href="#ip" aria-hidden="true">#</a> IP</h3><p>TCP 报文后续会被封装成 IP 报文进行发送。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191115534.jpeg" alt="IP 包头格式" tabindex="0" loading="lazy"><figcaption>IP 包头格式</figcaption></figure><ul><li>源地址 IP ：发送方的 IP 地址</li><li>目标地址 IP：接收方的 IP 地址；在 DNS 域名解析阶段获取的服务器 IP</li><li>协议号：<code>06</code> 表示 TCP 协议</li></ul><h4 id="生成-ip-报文" tabindex="-1"><a class="header-anchor" href="#生成-ip-报文" aria-hidden="true">#</a> 生成 IP 报文</h4><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191119831.jpeg" alt="IP 层报文" tabindex="0" loading="lazy"><figcaption>IP 层报文</figcaption></figure><h3 id="mac" tabindex="-1"><a class="header-anchor" href="#mac" aria-hidden="true">#</a> MAC</h3><p>生成 IP 报文之后，需要添加 MAC 头部：</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191122310.png" alt="MAC 包头格式" tabindex="0" loading="lazy"><figcaption>MAC 包头格式</figcaption></figure><ol><li><strong>发送方 MAC 地址</strong>：MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</li><li><strong>接收方目标 MAC 地址</strong>：通过 ARP 协议查询路由表获取 IP 地址对应的 MAC 地址</li><li><strong>协议类型</strong>：当前报文采用的协议 <ul><li><code>0800</code>：IP</li><li><code>0806</code>：ARP</li></ul></li></ol><h4 id="arp" tabindex="-1"><a class="header-anchor" href="#arp" aria-hidden="true">#</a> ARP</h4><p>ARP 协议通过广播的形式，获取 IP 对应的 MAC 地址。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191126972.png" alt="ARP 广播" tabindex="0" loading="lazy"><figcaption>ARP 广播</figcaption></figure><p>查询 MAC 地址流程：</p><ol><li>查询 ARP 缓存</li><li>若缓存不存在，发送 ARP 广播查询，并将查询结果加入缓存</li></ol><p>Linux 使用 <code>arp -a</code>查询 ARP 缓存。</p><h4 id="生成-mac-报文" tabindex="-1"><a class="header-anchor" href="#生成-mac-报文" aria-hidden="true">#</a> 生成 MAC 报文</h4><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191128493.jpeg" alt="MAC 层报文" tabindex="0" loading="lazy"><figcaption>MAC 层报文</figcaption></figure><h3 id="网卡" tabindex="-1"><a class="header-anchor" href="#网卡" aria-hidden="true">#</a> 网卡</h3><p>网卡将报文的二进制信息转化成电信号，进行发送。</p><p>网卡通过网卡驱动进行控制，网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191129479.png" alt="数据包" tabindex="0" loading="lazy"><figcaption>数据包</figcaption></figure><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的 <code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</li></ul><h3 id="交换机" tabindex="-1"><a class="header-anchor" href="#交换机" aria-hidden="true">#</a> 交换机</h3><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><ul><li><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p></li><li><p>然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p></li></ul><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备的 MAC 地址，</li><li>另一个是该设备连接在交换机的哪个端口上。</li></ul><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191131837.jpeg" alt="交换机的 MAC 地址表" tabindex="0" loading="lazy"><figcaption>交换机的 MAC 地址表</figcaption></figure><h4 id="若mac表中没有指定的-mac-地址时会如何" tabindex="-1"><a class="header-anchor" href="#若mac表中没有指定的-mac-地址时会如何" aria-hidden="true">#</a> 若MAC表中没有指定的 MAC 地址时会如何</h4><p>此时交换机会将包转发到除源端口的<strong>所有端口</strong>上，即发送广播：</p><ul><li>若非目标设备，则会忽略此报文</li><li>若为目标设备，则做出响应，交换机此时将 MAC 地址写入地址表中</li></ul><h3 id="路由器" tabindex="-1"><a class="header-anchor" href="#路由器" aria-hidden="true">#</a> 路由器</h3><h4 id="和交换机的区别" tabindex="-1"><a class="header-anchor" href="#和交换机的区别" aria-hidden="true">#</a> 和交换机的区别</h4><ul><li><strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li><strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul><h4 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h4><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p><h4 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程" aria-hidden="true">#</a> 工作流程</h4><ol><li>接收数据包： <ul><li>电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验</li><li>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</li></ul></li><li>查询路由，确定输出端口： <ul><li><strong>去掉</strong>包开头的 MAC 头部；<strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</li><li>获取报文中的 IP 头部</li><li>查询路由表，确当发送目标： <img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191140662.png" alt="路由器转发" loading="lazy"></li></ul></li><li>根据<strong>路由表的网关列</strong>判断对方的地址： <ul><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul></li><li>根据 ARP 协议获取下个转发目的地的 MAC 地址，发送数据包；在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</li></ol><h3 id="服务器" tabindex="-1"><a class="header-anchor" href="#服务器" aria-hidden="true">#</a> 服务器</h3><p>服务器收到数据包后，将数据包进行层层解析：</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191144916.png" alt="网络分层模型" tabindex="0" loading="lazy"><figcaption>网络分层模型</figcaption></figure><p>最终应用层收到的就是客户端发送的 HTTP 请求报文。</p>',125),o=[n];function l(c,s){return a(),e("div",null,o)}const d=i(t,[["render",l],["__file","1.basics.html.vue"]]);export{d as default};
