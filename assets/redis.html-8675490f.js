import{_ as e,X as i,Y as a,a1 as l}from"./framework-8cb7ec75.js";const r={},d=l('<h2 id="_1-数据结构及使用场景" tabindex="-1"><a class="header-anchor" href="#_1-数据结构及使用场景" aria-hidden="true">#</a> 1. 数据结构及使用场景</h2><ul><li>String 字符串 Key 都为字符串类型，Set key val 使用的是字符串；</li><li>Hash 哈希 键值对结构；</li><li>List 列表（双向链表） 存储多个有序的字符串；</li><li>Set 集合 集合中不允许有重复元素，元素是无序的。可以进行相关的集合计算（交并补等）；</li><li>Zset （Sorted Set，有序集合） 采用跳表实现，相较于 Set 多了 Score 从，元素可按照 Score 进行排列；</li></ul><h2 id="_2-持久化方式" tabindex="-1"><a class="header-anchor" href="#_2-持久化方式" aria-hidden="true">#</a> 2. 持久化方式</h2><ol><li>RDB ：快照形式将内存中的数据保存到一个 dump 文件中，定时保存； 当 Redis 需要持久化时，会 fork 一个子进程，子进程将数据写入磁盘上的临时 RDB 文件中。当子进程写完后，将原来的 RDB 替换掉。</li><li>AOF： 把所有的修改命令存到一个文件中； 使用 AOF 做持久化，每一个写命令都将追加到 <code>appendonly.aof</code> 文件中。AOF 的默认策略是每秒中同步一次。 缺点：AOF 文件体积大于 RDB，且相对较慢；</li></ol><p>Redis <strong>默认</strong>使用 RDB 快照。</p><h2 id="_3-数据过期-和-缓存淘汰-策略" tabindex="-1"><a class="header-anchor" href="#_3-数据过期-和-缓存淘汰-策略" aria-hidden="true">#</a> 3. 数据过期 和 缓存淘汰 策略</h2><h3 id="数据过期" tabindex="-1"><a class="header-anchor" href="#数据过期" aria-hidden="true">#</a> 数据过期</h3><ul><li><p>**定时过期：**每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p></li><li><p>**惰性过期：**只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p></li><li><p>**定期过期：**每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。(expires字典会保存所有设置了过期时间的key的过期时间数据，其中key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p></li></ul><p>Redis同时使用了惰性过期和定期过期两种过期策略。但是Redis定期删除是随机抽取机制，不可能扫描删除掉所有的过期Key。因此需要内存淘汰机制。</p><h3 id="缓存淘汰" tabindex="-1"><a class="header-anchor" href="#缓存淘汰" aria-hidden="true">#</a> 缓存淘汰</h3><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/redis-cache.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_4-单线程-redis-为什么快" tabindex="-1"><a class="header-anchor" href="#_4-单线程-redis-为什么快" aria-hidden="true">#</a> 4. 单线程 Redis 为什么快</h2><ul><li>纯内存操作</li><li>单线程操作，避免频繁的上下文切换</li><li>高效的数据结构</li><li>采用非阻塞 I/O 多路复用机制</li></ul><h2 id="_5-如何解决缓存雪崩" tabindex="-1"><a class="header-anchor" href="#_5-如何解决缓存雪崩" aria-hidden="true">#</a> 5. 如何解决缓存雪崩</h2><ul><li>使用 Redis 高可用架构：使用 Redis 集群保证 Redis 服务不会挂掉</li><li>缓存时间不一致，给缓存失效时间加上一个随机值，避免集体失效</li><li>限流降级 策略</li></ul><h2 id="_6-如何解决缓存穿透" tabindex="-1"><a class="header-anchor" href="#_6-如何解决缓存穿透" aria-hidden="true">#</a> 6. 如何解决缓存穿透</h2><ul><li>接口层做校验</li><li>存 NULL 值，缓存击穿加锁</li><li>布隆过滤器拦截：将所有可能的 Key 先映射到布隆过滤器中，查询时先判断是否存在布隆过滤器中，存在继续执行，不存在则返回；布隆过滤器中元素存在可能误判，元素不存在则一定不存在；</li></ul><h2 id="_7-主从-哨兵-集群" tabindex="-1"><a class="header-anchor" href="#_7-主从-哨兵-集群" aria-hidden="true">#</a> 7. 主从 哨兵 集群</h2><ul><li>主从模式 基于主从复制特性，主节点负责使用者的 IO 操作，从节点进行数据备份，并提供读操作；实现读写分离。 主节点宕机，其他从节点不会竞争称为主节点，会丧失写能力；</li><li>哨兵模式 相较于主从，多了竞选机制，从从节点中竞选出主节点；</li><li>集群模式 集群是提供在多个 Redis 节点间共享数据的程序集，中Redis集群分为主节点和从节点。主节点用于处理槽,而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线的主节点继续处理命令请求。</li></ul>',19),h=[d];function s(t,n){return i(),a("div",null,h)}const o=e(r,[["render",s],["__file","redis.html.vue"]]);export{o as default};
