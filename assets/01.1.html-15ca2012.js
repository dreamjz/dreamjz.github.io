import{_ as i,Z as l,$ as d,a0 as e,a1 as s,a2 as n,a5 as c,a3 as t,H as o}from"./framework-09afcf0b.js";const p={},h=t('<p>Redis 中使用 SDS (Simple Dynamic String, 简单动态字符串) 作为 Redis 的默认字符串表示。</p><p>Redis 中 ，C 字符串只会作为 字符串字面量 (string literal) 用在无须对字符串进行修改的地方，如打印日志。</p><p>而 SDS 将会用作：</p><ul><li>字符串值</li><li>缓冲区 (buffer): <ul><li>AOF 缓冲区</li><li>客户端状态中的输入缓冲区</li></ul></li></ul><h2 id="_1-1-sds-的定义" tabindex="-1"><a class="header-anchor" href="#_1-1-sds-的定义" aria-hidden="true">#</a> 1.1 SDS 的定义</h2>',5),u={href:"https://github.com/redis/redis/blob/3.0-alpha0/src/sds.h",target:"_blank",rel:"noopener noreferrer"},f=t(`<div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">{</span>
    <span class="token comment">// 记录 buf 数组中已使用的字节数量</span>
    <span class="token comment">// 等于 SDS 所保存的字符串的长度</span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span>
    <span class="token comment">// 记录 buf 中未使用的字节的数量</span>
    <span class="token keyword">int</span> free<span class="token punctuation">;</span>
    <span class="token comment">// 字节数组，用于保存字符串</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SDS 遵循 C 字符串以空字符结尾的惯例，保存空字符的 1 字节空间不计算在 SDS 的 len 属性中，且为其分配额外的 1 字节空间。这样的好处是可以直接复用一些 C 的库函数。</p><h2 id="_1-2-sds-与-c-字符串的区别" tabindex="-1"><a class="header-anchor" href="#_1-2-sds-与-c-字符串的区别" aria-hidden="true">#</a> 1.2 SDS 与 C 字符串的区别</h2><p>C 使用长度为 N+1 的字符数组表示长度为 N 的字符串，其最后一个元素总是空字符 <code>\\0</code>。</p><h3 id="_1-2-1-常数复杂度获取字符串长度" tabindex="-1"><a class="header-anchor" href="#_1-2-1-常数复杂度获取字符串长度" aria-hidden="true">#</a> 1.2.1 常数复杂度获取字符串长度</h3><p>因为 C 字符串并不记录自身的长度信息，所以获取 C 字符串长度必须遍历整个字符串，这个操作的时间复杂度为 <em>O(N)</em>。</p><p>在 SDS 中以 len 属性记录了 SDS 本身的长度，所以获取 SDS 长度的时间复杂度为 <em>O(1)</em>。</p><p>通过使用 SDS 而不是 C 字符串，Redis 将获取字符串长度的时间复杂度从 <em>O(N)</em> 降低到了 <em>O(1)</em>，确保了获取字符串长度不会称为 Redis 的性能瓶颈。例如：反复执行 <em>STRLEN</em> 指令不会对系统性能造成影响。</p><h3 id="_1-2-2-杜绝缓冲区溢出" tabindex="-1"><a class="header-anchor" href="#_1-2-2-杜绝缓冲区溢出" aria-hidden="true">#</a> 1.2.2 杜绝缓冲区溢出</h3><p>C 字符串不记录本身长度带来的另一个问题就是容易造成 缓冲区溢出 (buffer overflow)。</p><p>例如 <code>&lt;string.h&gt;/strcat</code>函数可以将字符串的内容拼接到 dest 字符串的末尾：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strcat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>函数 <code>strcat</code> 假定用户执行函数时，已经为 dest 分配了足够的内存用于容纳 src 的所有内容，一旦假设不成立将会造成缓冲区溢出，</p><p>比如，假设存在两个内存中相邻的字符串 s1 和 s2 ，s1 中保存 “Redis”，s2 保存 “MongoDB” 。</p><p>若欲执行</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">strcat</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> <span class="token string">&quot; Cluster&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>而忘记了为 s1 分配足够的空间，则在函数执行之后，s1 的数据将会溢出到 s2 的内存空间中，导致其数据被意外修改。</p><p>与 C 字符串不同，SDS 空间分配策略完全杜绝了缓冲区溢出：</p><ol><li>当 SDS API 需要对 SDS 进行修改时，API 会先检查 SDS 的空间是否满足修改需求</li><li>若不满足，API 会自动将 SDS 的空间扩展至执行修改所需的大小。再执行实际的修改操作</li></ol><p>故使用 SDS 无需手动修改 SDS 的空间大小，也不会出现缓存溢出的问题。</p><h3 id="_1-2-3-减少修改字符串带来的内存重分配次数" tabindex="-1"><a class="header-anchor" href="#_1-2-3-减少修改字符串带来的内存重分配次数" aria-hidden="true">#</a> 1.2.3 减少修改字符串带来的内存重分配次数</h3><p>因为 C 字符串不记录自身的长度，所以每次增长或缩短一个 C 字符串，都要其进行一次内存重分配操作：</p><ul><li>若执行<strong>增长</strong>字符串的操作，比如拼接 (append)，执行操作之前需要先通过内存分配来扩展底层数组的空间大小 (忘记此操作将会导致缓冲区溢出) 。</li><li>若执行<strong>缩短</strong>字符串的操作，比如截断 (trim),执行操作之后需要内存重分配来释放不再使用的内存空间 (忘记此操作将会导致内存泄漏<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>)。</li></ul><p>因为内存重新分配涉及复杂算法和系统调用，所以通常是比较耗时的操作：</p><ul><li>一般程序中，若修改字符串长度的情况不经常出现，那么每次修改都进行内存的重新分配是可以接受的。</li><li>Redis 作为数据库，经常用于速度要求严苛、数据频繁修改的场合。若每次修改都进行内存的重新分配，则会对性能造成影响。</li></ul><p>为了避免这些缺陷，SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf 数组的长度不一定为 len + 1，数组中可以包含未使用的字节，其数量存储在 free 属性中。</p><p>通过未使用空间，SDS 实现了空间预分配和惰性空间释放两种优化策略。</p><p><strong>1. 空间预分配</strong></p><p>空间预分配用于优化 SDS 的字符串<strong>增长</strong>操作：当 SDS API 对 SDS 进行修改并需要对其空间进行扩展时，不仅会分配修改所需的空间，还会分配额外的未使用空间。</p><p>额外空间数量由一下公式决定：</p><ul><li>修改后，SDS.buf &lt; 1MB，则分配和 len 同样大小的未使用空间，此时 free 和 len 相同（例如：SDS 修改后为 len 为13，则 free 也为 13， buf 实际长度为 27 = 13 + 13 + 1）。</li><li>修改后，SDS.buf &gt;= 1MB，则会额外分配 1MB 的空间（例如：buf 修改后为 30MB，则实际长度为 30MB + 1MB + 1Byte)。</li></ul><p>通过这种预分配策略，SDS 将连续增长 N 此字符串所需次数从必定 N 次降低为最多 N 次。</p><p><strong>2. 惰性空间释放</strong></p><p>惰性空间释放用于优化 SDS 的字符串<strong>缩短</strong>操作：当SDS API 需要缩短 SDS 保存的字符串时，不立即进行内存重分配来回收不再使用的字节，而是使用 free 属性记录下来等待下次使用。</p><p>通过惰性空间释放策略，SDS 避免了缩短字符串时所需的内存重分配操作，并未将来可能的增长操作提供了优化。</p><h3 id="_1-2-4-二进制安全" tabindex="-1"><a class="header-anchor" href="#_1-2-4-二进制安全" aria-hidden="true">#</a> 1.2.4 二进制安全</h3><p>C 字符串中不能包含空字符（会被认为是字符串结尾），故 C 字符串只能保存文本数据，而不能保存二进制数据。</p><p>SDS API 都是二进制安全的 (binary-safe<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>)，数据将会被当做二进制来处理，而不是字符。</p><h3 id="_1-2-5-兼容部分-c-字符串函数" tabindex="-1"><a class="header-anchor" href="#_1-2-5-兼容部分-c-字符串函数" aria-hidden="true">#</a> 1.2.5 兼容部分 C 字符串函数</h3><p>虽然 SDS API 都是二进制安全的，但其也遵守了 C 字符串中以空字符结尾的惯例，这样是为了让那些保存<strong>文本数据</strong>的 SDS 可以重用 C 字符串函数。</p><h2 id="_1-3-总结" tabindex="-1"><a class="header-anchor" href="#_1-3-总结" aria-hidden="true">#</a> 1.3 总结</h2><h3 id="_1-3-1-c-字符串和-sds-的区别" tabindex="-1"><a class="header-anchor" href="#_1-3-1-c-字符串和-sds-的区别" aria-hidden="true">#</a> 1.3.1 C 字符串和 SDS 的区别</h3>`,42),_=e("b",null,"表 1-1 Ｃ 字符串和 SDS 的区别",-1),S=t('<table><thead><tr><th>描述</th><th>C 字符串</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的时间复杂度</td><td>O(N)</td><td>O(1)</td></tr><tr><td>API 安全</td><td>API 不安全，可能会导致缓冲区溢出</td><td>API 安全，不会导致缓冲区溢出</td></tr><tr><td>内存分配</td><td>修改字符串长度 N 次<strong>必定</strong>进行 N 次内存重分配</td><td>修改字符串长度 N 次<strong>至多</strong>进行 N 次内存分配</td></tr><tr><td>保存内容</td><td>只能保存文本数据</td><td>可以保存文本数据或二进制数据</td></tr><tr><td>使用 &lt;string.h&gt; 库函数</td><td>可以使用所有</td><td>可以使用一部分</td></tr></tbody></table><h3 id="_1-3-2-小结" tabindex="-1"><a class="header-anchor" href="#_1-3-2-小结" aria-hidden="true">#</a> 1.3.2 小结</h3><ul><li>Redis 只会使用 C 字符串作为字面量 (stringn literal)，大多数情况下使用 SDS 来表示字符串</li><li>相较于 C 字符串，SDS 有以下优点： <ol><li>常数复杂度 (<em>O(1)</em>) 获取字符串长度</li><li>杜绝缓冲区溢出</li><li>减少修改字符串长度时所需的内存重分配次数</li><li>二进制安全</li><li>兼容部分 C 字符串函数</li></ol></li></ul><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2>',4),k={href:"https://book.douban.com/subject/25900156/",target:"_blank",rel:"noopener noreferrer"},b=e("hr",{class:"footnotes-sep"},null,-1),m={class:"footnotes"},g={class:"footnotes-list"},D={id:"footnote1",class:"footnote-item"},v={href:"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F",target:"_blank",rel:"noopener noreferrer"},C=e("strong",null,"内存泄漏",-1),x={href:"https://zh.wikipedia.org/wiki/%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F",target:"_blank",rel:"noopener noreferrer"},w={href:"https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86",target:"_blank",rel:"noopener noreferrer"},B={href:"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98",target:"_blank",rel:"noopener noreferrer"},E=e("a",{href:"#footnote-ref1",class:"footnote-backref"},"↩︎",-1),y={id:"footnote2",class:"footnote-item"},A={href:"https://en.wikipedia.org/wiki/Binary-safe",target:"_blank",rel:"noopener noreferrer"},N=e("strong",null,"binary-safe",-1),I=e("a",{href:"#footnote-ref2",class:"footnote-backref"},"↩︎",-1);function R(P,O){const a=o("ExternalLinkIcon"),r=o("center");return l(),d("div",null,[h,e("p",null,[s("每个 "),e("a",u,[s("sds.h/sdshdr"),n(a)]),s(" 结构表示一个 SDS 值：")]),f,n(r,null,{default:c(()=>[_]),_:1}),S,e("ol",null,[e("li",null,[e("a",k,[s("Redis设计与实现"),n(a)])])]),b,e("section",m,[e("ol",g,[e("li",D,[e("p",null,[e("a",v,[C,n(a)]),s("（英语：memory leak）是一种"),e("a",x,[s("资源泄漏"),n(a)]),s("，主因是计算机程序对"),e("a",w,[s("存储器配置管理"),n(a)]),s("失当，失去对一段已分配内存空间的控制，造成程序继续占用已经不再使用的"),e("a",B,[s("内存"),n(a)]),s("空间，或是存储器所存储之对象无法透过执行代码而访问，令内存资源空耗 "),E])]),e("li",y,[e("p",null,[s("A "),e("a",A,[N,n(a)]),s(" function is one that treats its input as a raw stream of bytes and ignores every textual aspect it may have "),I])])])])])}const z=i(p,[["render",R],["__file","01.1.html.vue"]]);export{z as default};
