const l=JSON.parse('{"key":"v-5d9f6a3b","path":"/interview/network/3.tcp.html","title":"3. TCP","lang":"zh-CN","frontmatter":{"title":"3. TCP"},"headers":[{"level":2,"title":"3.1 TCP 报文头","slug":"_3-1-tcp-报文头","link":"#_3-1-tcp-报文头","children":[]},{"level":2,"title":"3.2 为什么需要 TCP？TCP 工作在那一层？","slug":"_3-2-为什么需要-tcp-tcp-工作在那一层","link":"#_3-2-为什么需要-tcp-tcp-工作在那一层","children":[{"level":3,"title":"为什么需要 TCP","slug":"为什么需要-tcp","link":"#为什么需要-tcp","children":[]},{"level":3,"title":"TCP 工作在那一层","slug":"tcp-工作在那一层","link":"#tcp-工作在那一层","children":[]}]},{"level":2,"title":"3.3 什么是TCP","slug":"_3-3-什么是tcp","link":"#_3-3-什么是tcp","children":[]},{"level":2,"title":"3.4 什么是 TCP 连接","slug":"_3-4-什么是-tcp-连接","link":"#_3-4-什么是-tcp-连接","children":[]},{"level":2,"title":"3.5 如何唯一确定一个 TCP 连接","slug":"_3-5-如何唯一确定一个-tcp-连接","link":"#_3-5-如何唯一确定一个-tcp-连接","children":[]},{"level":2,"title":"3.6 有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？","slug":"_3-6-有一个-ip-的服务端监听了一个端口-它的-tcp-的最大连接数是多少","link":"#_3-6-有一个-ip-的服务端监听了一个端口-它的-tcp-的最大连接数是多少","children":[]},{"level":2,"title":"3.7 TCP 和 UDP 的区别，有哪些应用场景","slug":"_3-7-tcp-和-udp-的区别-有哪些应用场景","link":"#_3-7-tcp-和-udp-的区别-有哪些应用场景","children":[{"level":3,"title":"UDP","slug":"udp","link":"#udp","children":[]},{"level":3,"title":"区别","slug":"区别","link":"#区别","children":[]},{"level":3,"title":"应用场景","slug":"应用场景","link":"#应用场景","children":[]}]},{"level":2,"title":"3.8 TCP 和 UDP 可以使用同一个端口吗","slug":"_3-8-tcp-和-udp-可以使用同一个端口吗","link":"#_3-8-tcp-和-udp-可以使用同一个端口吗","children":[]},{"level":2,"title":"3.9 TCP 连接建立过程 - 三次握手","slug":"_3-9-tcp-连接建立过程-三次握手","link":"#_3-9-tcp-连接建立过程-三次握手","children":[]},{"level":2,"title":"3.10 为什么是三次握手","slug":"_3-10-为什么是三次握手","link":"#_3-10-为什么是三次握手","children":[{"level":3,"title":"原因一：避免历史连接","slug":"原因一-避免历史连接","link":"#原因一-避免历史连接","children":[]},{"level":3,"title":"原因二：同步双方初始序列号","slug":"原因二-同步双方初始序列号","link":"#原因二-同步双方初始序列号","children":[]},{"level":3,"title":"原因三：避免资源浪费","slug":"原因三-避免资源浪费","link":"#原因三-避免资源浪费","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]}]},{"level":2,"title":"3.11 为何每次建立的 TCP 连接，初始化的序列号要求都不一样","slug":"_3-11-为何每次建立的-tcp-连接-初始化的序列号要求都不一样","link":"#_3-11-为何每次建立的-tcp-连接-初始化的序列号要求都不一样","children":[]},{"level":2,"title":"3.12 初始序列号如何产生","slug":"_3-12-初始序列号如何产生","link":"#_3-12-初始序列号如何产生","children":[]},{"level":2,"title":"3.13 MSS 和 MTU","slug":"_3-13-mss-和-mtu","link":"#_3-13-mss-和-mtu","children":[]},{"level":2,"title":"3.14 为何要在 TCP 层分片，而不是在 IP 层分片","slug":"_3-14-为何要在-tcp-层分片-而不是在-ip-层分片","link":"#_3-14-为何要在-tcp-层分片-而不是在-ip-层分片","children":[]},{"level":2,"title":"3.15 当第一次握手丢失之后会发生什么","slug":"_3-15-当第一次握手丢失之后会发生什么","link":"#_3-15-当第一次握手丢失之后会发生什么","children":[]},{"level":2,"title":"3.16 第二次握手报文丢失会发生什么","slug":"_3-16-第二次握手报文丢失会发生什么","link":"#_3-16-第二次握手报文丢失会发生什么","children":[]},{"level":2,"title":"3.17 第三次握手丢失会发生什么","slug":"_3-17-第三次握手丢失会发生什么","link":"#_3-17-第三次握手丢失会发生什么","children":[]},{"level":2,"title":"3.17 什么是 SYN 攻击？如何避免","slug":"_3-17-什么是-syn-攻击-如何避免","link":"#_3-17-什么是-syn-攻击-如何避免","children":[{"level":3,"title":"半连接 和 全连接 队列","slug":"半连接-和-全连接-队列","link":"#半连接-和-全连接-队列","children":[]},{"level":3,"title":"如何避免","slug":"如何避免","link":"#如何避免","children":[]}]},{"level":2,"title":"3.18 四次挥手","slug":"_3-18-四次挥手","link":"#_3-18-四次挥手","children":[]},{"level":2,"title":"3.19 为什么需要四次挥手","slug":"_3-19-为什么需要四次挥手","link":"#_3-19-为什么需要四次挥手","children":[]},{"level":2,"title":"3.20 为什么 TIME_WAIT 时间为 2*MSL","slug":"_3-20-为什么-time-wait-时间为-2-msl","link":"#_3-20-为什么-time-wait-时间为-2-msl","children":[{"level":3,"title":"MSL 和 TTL","slug":"msl-和-ttl","link":"#msl-和-ttl","children":[]},{"level":3,"title":"为什么是 2 倍 MSL","slug":"为什么是-2-倍-msl","link":"#为什么是-2-倍-msl","children":[]}]},{"level":2,"title":"3.21 若第一次挥手丢失，会发生什么","slug":"_3-21-若第一次挥手丢失-会发生什么","link":"#_3-21-若第一次挥手丢失-会发生什么","children":[]},{"level":2,"title":"3.22 第二次挥手丢失了，会发生什么","slug":"_3-22-第二次挥手丢失了-会发生什么","link":"#_3-22-第二次挥手丢失了-会发生什么","children":[]},{"level":2,"title":"3.23 第三次挥手丢失了，会发生什么","slug":"_3-23-第三次挥手丢失了-会发生什么","link":"#_3-23-第三次挥手丢失了-会发生什么","children":[]},{"level":2,"title":"3.24 第四次挥手丢失了，会发生什么","slug":"_3-24-第四次挥手丢失了-会发生什么","link":"#_3-24-第四次挥手丢失了-会发生什么","children":[]},{"level":2,"title":"3.25 为什么需要 TIME_WAIT 状态","slug":"_3-25-为什么需要-time-wait-状态","link":"#_3-25-为什么需要-time-wait-状态","children":[{"level":3,"title":"原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收","slug":"原因一-防止历史连接中的数据-被后面相同四元组的连接错误的接收","link":"#原因一-防止历史连接中的数据-被后面相同四元组的连接错误的接收","children":[]},{"level":3,"title":"原因二：保证「被动关闭连接」的一方，能被正确的关闭","slug":"原因二-保证「被动关闭连接」的一方-能被正确的关闭","link":"#原因二-保证「被动关闭连接」的一方-能被正确的关闭","children":[]}]},{"level":2,"title":"3.26 TIME_WAIT 过多的危害","slug":"_3-26-time-wait-过多的危害","link":"#_3-26-time-wait-过多的危害","children":[]},{"level":2,"title":"3.27 TCP 重传机制","slug":"_3-27-tcp-重传机制","link":"#_3-27-tcp-重传机制","children":[{"level":3,"title":"超时重传","slug":"超时重传","link":"#超时重传","children":[]},{"level":3,"title":"快速重传","slug":"快速重传","link":"#快速重传","children":[]},{"level":3,"title":"SACK 方法","slug":"sack-方法","link":"#sack-方法","children":[]},{"level":3,"title":"Duplicate SACK","slug":"duplicate-sack","link":"#duplicate-sack","children":[]}]},{"level":2,"title":"3.28 TCP 滑动窗口","slug":"_3-28-tcp-滑动窗口","link":"#_3-28-tcp-滑动窗口","children":[{"level":3,"title":"如何决定窗口大小","slug":"如何决定窗口大小","link":"#如何决定窗口大小","children":[]},{"level":3,"title":"发送方的滑动窗口","slug":"发送方的滑动窗口","link":"#发送方的滑动窗口","children":[]},{"level":3,"title":"接收方滑动窗口","slug":"接收方滑动窗口","link":"#接收方滑动窗口","children":[]},{"level":3,"title":"接收窗口和发送窗口的大小是相等的吗","slug":"接收窗口和发送窗口的大小是相等的吗","link":"#接收窗口和发送窗口的大小是相等的吗","children":[]}]},{"level":2,"title":"3.29 TCP 流量控制","slug":"_3-29-tcp-流量控制","link":"#_3-29-tcp-流量控制","children":[{"level":3,"title":"操作系统缓冲区和滑动窗口","slug":"操作系统缓冲区和滑动窗口","link":"#操作系统缓冲区和滑动窗口","children":[]},{"level":3,"title":"窗口关闭","slug":"窗口关闭","link":"#窗口关闭","children":[]},{"level":3,"title":"糊涂窗口综合症","slug":"糊涂窗口综合症","link":"#糊涂窗口综合症","children":[]}]},{"level":2,"title":"3.30 拥塞控制","slug":"_3-30-拥塞控制","link":"#_3-30-拥塞控制","children":[]},{"level":2,"title":"3.31 TCP 的 Keepalive 和 HTTP 的 Keep-Alive","slug":"_3-31-tcp-的-keepalive-和-http-的-keep-alive","link":"#_3-31-tcp-的-keepalive-和-http-的-keep-alive","children":[{"level":3,"title":"HTTP 的 Keep-Alive","slug":"http-的-keep-alive","link":"#http-的-keep-alive","children":[]},{"level":3,"title":"TCP 的 Keepalive","slug":"tcp-的-keepalive","link":"#tcp-的-keepalive","children":[]},{"level":3,"title":"小结","slug":"小结-1","link":"#小结-1","children":[]}]}],"git":{"updatedTime":1698123705000},"readingTime":{"minutes":56.49,"words":16947},"filePathRelative":"interview/network/3.tcp.md","excerpt":"<h2> 3.1 TCP 报文头</h2>\\n<figure><img src=\\"https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310191349145.png\\" alt=\\"TCP 头格式\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>TCP 头格式</figcaption></figure>\\n<p>主要字段：</p>\\n<ul>\\n<li>序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></li>\\n<li><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></li>\\n<li><strong>控制位：</strong>\\n<ul>\\n<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>\\n<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>\\n<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>\\n<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段</li>\\n</ul>\\n</li>\\n</ul>"}');export{l as data};
