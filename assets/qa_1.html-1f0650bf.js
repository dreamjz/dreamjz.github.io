import{_ as e,Z as o,$ as a,a4 as d}from"./framework-d03928c9.js";const i={},n=d('<h2 id="_1-basics" tabindex="-1"><a class="header-anchor" href="#_1-basics" aria-hidden="true">#</a> 1. Basics</h2><h3 id="_1-1-常用索引有哪些" tabindex="-1"><a class="header-anchor" href="#_1-1-常用索引有哪些" aria-hidden="true">#</a> 1.1 常用索引有哪些</h3><p>普通索引、唯一索引、主键索引、组合索引、全文索引</p><p><strong>普通索引</strong>：基本索引类型，用于加速系统对数据的访问速度</p><p>例如，建立 index_id 在 tb_student 表上：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> index_id <span class="token keyword">ON</span> tb_student<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>唯一索引</strong>：索引值必须唯一，允许空值</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> <span class="token keyword">UNIQUE</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>主键索引</strong>：特殊唯一索引，不允许空值</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>column<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>组合索引</strong>：一个索引包含多个列</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span> <span class="token identifier"><span class="token punctuation">`</span>column1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>column2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>column3<span class="token punctuation">`</span></span> <span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>全文索引</strong>：仅用于 MyISAM，用于检索长文本</p><h3 id="_1-2-聚集索引和非聚集索引的区别" tabindex="-1"><a class="header-anchor" href="#_1-2-聚集索引和非聚集索引的区别" aria-hidden="true">#</a> 1.2 聚集索引和非聚集索引的区别</h3><ul><li>聚集索引(Clustered Index)： <ul><li>聚集索引的数据行和索引的顺序相同，即其将数据行本身和索引按照相同的排序方式存储</li><li>一个表只能有一个聚集索引，因为数据行只能以一种顺序存储</li><li>聚集索引通常用主键建立，也可以使用其他具有唯一约束的列</li><li>数据的物理存储顺序和索引的顺序相同，故聚集索引通常提供较快的数据检索</li></ul></li><li>非聚集索引(Non-clustered Index)： <ul><li>非聚集索引与聚集索引分开存储，数据行的顺序与索引的顺序无关</li><li>一个表可以有多个非聚集索引</li><li>非聚集索引包含用于检索的键值和一个指针，指向行数据的实际位置</li><li>非聚集索引通常用于在不同于主键的其他列上提高查询性能</li></ul></li></ul><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h4><p>聚集索引按照索引顺序存储数据行，而非聚集索引将索引与数据行分开存储。</p><p>一个表只能有一个聚集索引，但可以有多个非聚集索引。</p><p>在查询性能上，聚集索引通常提供较快的数据检索，而非聚集索引则在其他列上提高查询性能。</p><h3 id="_1-3-mysql-为什么使用-b-tree-作为存储的数据结构" tabindex="-1"><a class="header-anchor" href="#_1-3-mysql-为什么使用-b-tree-作为存储的数据结构" aria-hidden="true">#</a> 1.3 MySQL 为什么使用 B+ Tree 作为存储的数据结构</h3><p><code>MySQL</code> 使用 <code>B+</code>树（<code>B+Tree</code>）作为存储数据结构的主要原因是其在查询性能、空间利用和磁盘<code>IO</code>效率方面的优势。以下是 <code>B+</code>树在数据库中具有优势的几个方面：</p><ol><li><strong>查询性能</strong>：B+树使一种自平衡的多路搜索树，这意味着它能够在树的深度方面保持相对均衡。这样，在查找数据时，即使数据量非常大，也能保证较低的查询成本。</li><li><strong>范围查询</strong>：B+树的叶子节点的记录(或键值)是有序的，使得其适合进行范围查询。</li><li><strong>I/O 效率</strong>：B+树的结构使其能够很好的处理磁盘I/O，在B+树中所有的数据记录都存在叶子节点中，非叶子节点只包含索引信息。这样I/O次数将会减少，提高查询性能。</li><li><strong>空间利用</strong>：B+树的内部节点只存储索引信息而不存储实际数据，所以每个内部节点可容纳的索引量更多，树的高度将更低。意味着磁盘空间能够被更有效的利用。</li></ol><h3 id="_1-4-mysql-的-b-tree-非叶子节点有多少数据-一般有几层" tabindex="-1"><a class="header-anchor" href="#_1-4-mysql-的-b-tree-非叶子节点有多少数据-一般有几层" aria-hidden="true">#</a> 1.4 Mysql 的 B+Tree 非叶子节点有多少数据，一般有几层</h3><p>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用 4 个字节）或 BIGINT（占用 8 个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值（因为是估值，为方便计算，这里的 K 取值为〖10〗^3）。也就是说一个深度为 3 的 B+Tree 索引可以维护 10^3 _ 10^3 _ 10^3 = 10 亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree</code> 的高度一般都在<code>2~4</code>层。<code>mysql</code>的<code>InnoDB</code>存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要<code>1~3</code>次磁盘<code>I/O</code>操作。</p><h3 id="_1-5-myisam、innodb-索引实现" tabindex="-1"><a class="header-anchor" href="#_1-5-myisam、innodb-索引实现" aria-hidden="true">#</a> 1.5 MyISAM、InnoDB 索引实现</h3><p><code>MyISAM</code>引擎使用<code>B+Tree</code>作为索引结构，叶节点的<code>data</code>域存放的是数据记录的地址。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310172036911.webp" alt="Primary Key.png" tabindex="0" loading="lazy"><figcaption>Primary Key.png</figcaption></figure><p>在<code>MyISAM</code>中，主索引和辅助索引（<code>Secondary key</code>）在结构上没有任何区别，只是主索引要求<code>key</code>是唯一的，而辅助索引的<code>key</code>可以重复。</p><p>区别：</p><ul><li><code>InnoDB</code>的数据文件本身就是索引文件。 表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构，这棵树的叶节点<code>data</code>域保存了完整的数据记录。这个索引的<code>key</code>是数据表的主键，因此<code>InnoDB</code>表数据文件本身就是主索引。</li><li><code>MyISAM</code>索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</li></ul><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310172040174.webp" alt="Primary Key.png" tabindex="0" loading="lazy"><figcaption>Primary Key.png</figcaption></figure><h3 id="_1-6-myisam与innodb的主要区别" tabindex="-1"><a class="header-anchor" href="#_1-6-myisam与innodb的主要区别" aria-hidden="true">#</a> 1.6 MyISAM与InnoDB的主要区别</h3><h4 id="事务支持-transaction-support" tabindex="-1"><a class="header-anchor" href="#事务支持-transaction-support" aria-hidden="true">#</a> 事务支持 (Transaction Support)</h4><ul><li><code>MyISAM</code>: <code>MyISAM </code>不支持事务。不适用于需要处理复杂事务和严格保证数据完整性的场景。</li><li><code>InnoDB</code>：<code>InnoDB </code>支持事务(ACID)，提供提交、回滚等事务相关操作，适用于处理复杂业务并确保数据完整性。</li></ul><h4 id="行级锁定-row-level-locking" tabindex="-1"><a class="header-anchor" href="#行级锁定-row-level-locking" aria-hidden="true">#</a> 行级锁定(Row-level Locking)</h4><ul><li><code>MyISAM</code>：使用表级锁定，当对表进行写操作（插入、删除和更新）时，会锁定整个表。将降低并发性能</li><li><code>InnoDB</code>：使用行级锁定，允许高并发环境下对多个记录进行读写访问，提高数据库性能</li></ul><h4 id="数据存储和索引" tabindex="-1"><a class="header-anchor" href="#数据存储和索引" aria-hidden="true">#</a> 数据存储和索引</h4><ul><li><code>MyISAM</code>：将数据和索引文件分开存储。主要支持非聚集索引</li><li><code>InnoDB</code>：以聚集的方式组织存储，支持聚集和非聚集索引。索引按照相同顺序存储，提高了查询性能</li></ul><h4 id="数据完整性-data-integrity" tabindex="-1"><a class="header-anchor" href="#数据完整性-data-integrity" aria-hidden="true">#</a> 数据完整性(Data Integrity)</h4><ul><li><code>MyISAM</code>：不支持外键约束，无法保证数据间的引用完整性</li><li><code>InnoDB</code>：支持外键约束，可以在数据表间维护引用关系，确保数据完整性</li></ul><h4 id="崩溃恢复-crash-recovery" tabindex="-1"><a class="header-anchor" href="#崩溃恢复-crash-recovery" aria-hidden="true">#</a> 崩溃恢复(Crash Recovery)</h4><ul><li><code>MyISAM</code>：不具备原生的崩溃恢复能力。在数据库崩溃或电源故障的情况下可能造成数据损坏或丢失</li><li><code>InnoDB</code>：提供日志和检查点(Check Point)机制，支持故障和现场恢复。</li></ul><h4 id="全文搜索-full-text-search" tabindex="-1"><a class="header-anchor" href="#全文搜索-full-text-search" aria-hidden="true">#</a> 全文搜索(Full-text Search)</h4><ul><li><code>MyISAM</code>：提供全文搜索功能</li><li><code>InnoDB</code>：早期不支持，5.6.4 之后也支持</li></ul><h4 id="小结-1" tabindex="-1"><a class="header-anchor" href="#小结-1" aria-hidden="true">#</a> 小结</h4><ul><li><p><code>MyISAM</code>更适合用于读取速度要求高、不要求事务支持和数据完整性严格保障的简单查询场景。</p></li><li><p><code>InnoDB </code>更适合事务处理、并发读写较高且需要保证数据完整性的场景。</p></li></ul><p>在实际应用中，根据不同的需求和场景选择合适的存储引擎非常重要。</p><h3 id="_1-7-为字段建立索引的好处-越多越好么" tabindex="-1"><a class="header-anchor" href="#_1-7-为字段建立索引的好处-越多越好么" aria-hidden="true">#</a> 1.7 为字段建立索引的好处？越多越好么？</h3><p>建立索引的好处：</p><ol><li><strong>提高查询速度</strong>；通过索引可以避免扫描全表，而是直接定位到记录，节省查询时间</li><li><strong>加速排序和分组</strong>；索引可以用于对排序和分组操作进行优化，提高查询性能</li><li><strong>支持外键约束</strong>；<code>InnoDB</code>中，索引可用于支持外键约束，确保数据引用的完整性</li></ol><p>索引不是越多越好，索引的缺点：</p><ol><li><strong>占用存储空间</strong>；索引需要额外的存储空间，过多的索引会占用更多的磁盘空间</li><li><strong>数据插入、更新和删除性能</strong>；数据库在插入、更新和删除数据时，需要维护相关索引，过多的索引会影响性能。</li><li><strong>索引维护成本</strong>：索引需要维护，包括碎片整理、索引重建等操作。过多的索引意味着更高的维护成本。</li></ol><h4 id="小结-2" tabindex="-1"><a class="header-anchor" href="#小结-2" aria-hidden="true">#</a> 小结</h4><p>创建索引可以提高数据库查询性能，但是过多的索引会导致额外的存储空间和性能开销。在创建索引时，应根据实际需求进行适当的权衡。</p><h3 id="_1-8-mysql-慢查询常见原因" tabindex="-1"><a class="header-anchor" href="#_1-8-mysql-慢查询常见原因" aria-hidden="true">#</a> 1.8 MySQL 慢查询常见原因</h3><p><code>MySQL</code>慢查询可能出现的原因有很多。以下是一些常见的慢查询原因：</p><ol><li><strong>缺少索引或使用不当</strong>：未对查询中的关键字段创建索引、索引选取不当或统计信息不准确，导致 MySQL 无法高效地查询数据，从而降低查询速度。</li><li><strong>查询语句设计不合理</strong>：复杂的子查询、使用了大量的临时表、笛卡尔积查询等，可能导致查询性能低下。</li><li><strong>数据量过大</strong>：当表中的数据量过大时，未经优化的查询可能需要处理大量数据，从而降低查询速度。</li><li><strong>锁争用</strong>：在高并发读写的场景下，如果 MySQL 存储引擎（如 MyISAM）使用表级锁或行级锁锁定不当，可能导致锁争用，进而降低查询性能。</li><li><strong>硬件资源限制</strong>：如 CPU、内存、磁盘和网络等硬件资源不足，可能导致查询性能低下。</li><li><strong>MySQL 配置不当</strong>：MySQL 的配置参数未经优化，可能在一定程度上影响查询性能（如缓冲区大小不合适、连接数设置不正确等）。</li><li><strong>数据分布不均</strong>：在使用分布式数据库或分区表时，如果数据分布不均匀，可能导致部分查询性能较低。</li><li><strong>过时的统计信息</strong>：MySQL 使用统计信息来选择最佳索引。如果统计信息过时或不准确，可能导致 MySQL 选择不佳的查询计划。</li></ol><p>针对这些常见的慢查询原因，可以采取相应措施进行优化。</p><p>例如：创建和优化索引、改进查询语句、调整硬件配置、优化 <code>MySQL</code>参数设置等。同时，可以开启慢查询日志来分析和诊断慢查询问题。</p><h3 id="_1-9-sql-优化原则-索引注意事项" tabindex="-1"><a class="header-anchor" href="#_1-9-sql-优化原则-索引注意事项" aria-hidden="true">#</a> 1.9 SQL 优化原则，索引注意事项？</h3><h4 id="sql-优化原则" tabindex="-1"><a class="header-anchor" href="#sql-优化原则" aria-hidden="true">#</a> SQL 优化原则</h4><ol><li><strong>减少数据请求量</strong>：尽量减少请求的数据量，只请求需要的列和必要的记录。</li><li><strong>避免 SELECT * 查询</strong>：仅查询所需的列，以减少数据传输和处理的开销。</li><li><strong>优化连接和子查询</strong>：连接查询时，避免全外连接（Full Outer Join）和笛卡尔积连接，而使用内连接（Inner Join）或左（右）连接（Left/Right Join）。尽量减少子查询，考虑使用连接查询或者临时表代替。</li><li><strong>分批处理数据</strong>：如果需要处理大量数据，可以使用分页查询、limit 语句或其他批处理技术，以降低数据处理压力。</li><li><strong>利用索引</strong>：在查询语句中使用索引相关的列，尽量避免对索引字段进行计算、函数或表达式操作，以充分利用现有索引加速查询。</li><li><strong>避免隐式类型转换</strong>：确保在查询中进行比较或计算的字段类型匹配，以避免隐式类型转换导致查询性能下降。</li><li><strong>聚合操作优化</strong>：在对大量数据执行聚合查询（如求和、计数等）时，尽量使用索引进行覆盖查询，减少数据扫描量。</li></ol><h4 id="索引注意事项" tabindex="-1"><a class="header-anchor" href="#索引注意事项" aria-hidden="true">#</a> 索引注意事项</h4><ol><li><strong>选择合适的索引列</strong>：在查询中常用作过滤、连接和排序的列是创建索引的最佳候选。另外，考虑数据的区分度，数据分布较均匀且重复值较少的列更适合创建索引。</li><li><strong>避免过多索引</strong>：索引虽然可以提高查询性能，但它会占用额外的存储空间并影响数据的插入、更新和删除操作。因此，应权衡实际情况，充分考虑查询需求和数据变更频率，以避免过多索引。</li><li><strong>使用组合索引</strong>：在多个字段上经常一起进行查询的场景，可以创建组合索引。但应注意，组合索引的顺序会影响到查询性能。</li><li><strong>避免在索引列上进行计算、函数或表达式操作</strong>：在 SQL 查询中，尽量不要对索引列进行计算、使用函数或进行表达式操作，这会导致索引失效。</li><li><strong>定期评估索引效果</strong>：定期评估现有索引的使用情况、查询性能和索引开销等方面，根据实际需求添加、删除或调整索引。</li><li><strong>考虑使用部分索引</strong>：如果某个列上只有部分数据需要被查询，可以考虑创建部分索引，以降低索引维护成本。</li></ol><p>结合实际数据库使用情况调整和优化 SQL 查询语句以及索引策略，有助于提升数据库查询性能和整体性能。所采取的优化措施应根据业务需求、数据量级和具体场景进行调整。</p><h3 id="_1-10-事务的-acid" tabindex="-1"><a class="header-anchor" href="#_1-10-事务的-acid" aria-hidden="true">#</a> 1.10 事务的 ACID</h3><ul><li>原子性（<code>Atomicity</code>）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li><li>一致性（<code>Consistent</code>）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如 B 树索引或双向链表）也都必须是正确的。</li><li>隔离性（<code>Isolation</code>）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li><li>持久性（<code>Durable</code>）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li></ul><h3 id="_1-11-事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#_1-11-事务的隔离级别" aria-hidden="true">#</a> 1.11 事务的隔离级别</h3><table><thead><tr><th>读数据一致性及并发副作用</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交(read uncommitted)</td><td>最低级别，不读物理上损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交(read committed)</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读(Repeatable read)</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr><td>可序列化(Serializable)</td><td>最高级别，事务级</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><ul><li>更新丢失(Lost Update)：当两个或多个事务选择同一行，然后基于最初选定的值更新，由于事务不知道其他事务的存在，导致最后的更新覆盖其他事务更新，发生更新丢失。</li><li>脏读(Dirty Reads)：一个事务正在对记录进行修改，在提交之前，另一个事务读取该记录，此时读取到的是脏数据。</li><li>不可重复读(Non-repeatable Reads)：一个事务在读取某些数据后，再次读取时，数据被修改或已删除</li><li>幻读(Phantom Reads)：一个事务按照相同的条件重新读取之前检索过的数据，读取到其他事务新插入的满足条件的数据。</li></ul><h3 id="_1-12-什么是当前读和快照读" tabindex="-1"><a class="header-anchor" href="#_1-12-什么是当前读和快照读" aria-hidden="true">#</a> 1.12 什么是当前读和快照读？</h3><h4 id="当前读" tabindex="-1"><a class="header-anchor" href="#当前读" aria-hidden="true">#</a> 当前读</h4><p>读取的记录的最新版本，读取时保证其他并发事务不能修改当前记录，会对记录进行加锁。</p><ul><li><code>select lock in share mode</code>(共享锁)</li><li><code>select for update</code> ， <code>update</code>, <code>insert</code> ,<code>delete</code>(排他锁)</li></ul><p>这些操作都是一种当前读。</p><h4 id="快照读" tabindex="-1"><a class="header-anchor" href="#快照读" aria-hidden="true">#</a> 快照读</h4><p>不加锁的非阻塞读，基于多版本并发控制<code>MVCC</code>。</p><p>特性：</p><ol><li>快照读读取的不一定是最新版本，可能是之前的历史版本</li><li>当隔离级别为串行级别(Serializable)，快照读将退化成当前读</li></ol><p>不加锁的<code>SELECT</code>操作就是快照读。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310180835025.webp" alt="leck in shave mwe.png" tabindex="0" loading="lazy"><figcaption>leck in shave mwe.png</figcaption></figure><h3 id="_1-13-什么是mvcc" tabindex="-1"><a class="header-anchor" href="#_1-13-什么是mvcc" aria-hidden="true">#</a> 1.13 什么是MVCC</h3><p>MVCC(Multi-Version Concurrency Control，多版本并发控制) 是一种允许多个事务同时访问数据库的技术，旨在提高数据库在高并发环境下的性能。</p><h4 id="核心思想" tabindex="-1"><a class="header-anchor" href="#核心思想" aria-hidden="true">#</a> 核心思想</h4><p>在同一个事务中，对同一个数据的多次查询始终保持一致性，而不加锁来实现隔离，以避免加锁带来的性能损耗。</p><h4 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h4><p>MVCC 通过为每行数据生成多个版本，在不同的事物中访问不同版本的数据，实现并发控制。</p><p>每个事务开始时将会获得唯一的事务ID，读取的数据行需要满足以下条件：</p><ol><li>数据行的<strong>创建</strong>版本<strong>小于等于</strong>事务ID</li><li>数据行的<strong>删除</strong>版本大于等于事务ID</li></ol><p>每个事务将能以一致的快照(snapshot)视图访问数据库，且互不影响。</p><p>每行记录除了用户自定义字段外，还有数据库隐式定义字段：</p><ul><li><code>DB_TRX_ID</code>，<code>6byte</code>，最近修改(修改/插入)事务<code>ID</code>：记录创建这条记录/最后一次修改该记录的事务<code>ID</code></li><li><code>DB_ROLL_PTR</code>，<code>7byte</code>，回滚指针，指向这条记录的上一个版本（存储于<code>rollback segment</code>里）</li><li><code>DB_ROW_ID</code>，<code>6byte</code>，隐含的自增<code>ID</code>（隐藏主键），如果数据表没有主键，<code>InnoDB</code>会自动以<code>DB_ROW_ID</code>产生一个聚簇索引</li><li>删除<code>flag</code>隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除<code>flag</code>变了。</li></ul><h3 id="_1-14-事务开始的时机" tabindex="-1"><a class="header-anchor" href="#_1-14-事务开始的时机" aria-hidden="true">#</a> 1.14 事务开始的时机</h3><p><code>begin/start transaction</code>不是事务的起点，执行之后的第一个操作数据表的语句时才会启动事务。</p><p><code>start transaction with consistent snapshot</code> 可以立刻启动事务。</p><h3 id="_1-15-什么是预读" tabindex="-1"><a class="header-anchor" href="#_1-15-什么是预读" aria-hidden="true">#</a> 1.15 什么是预读</h3><p>读取硬盘数据，是按页读取，一次至少读取一页的数据，能够减少I/O，提高效率。</p><h3 id="_1-16-什么是缓存池-buffer-pool" tabindex="-1"><a class="header-anchor" href="#_1-16-什么是缓存池-buffer-pool" aria-hidden="true">#</a> 1.16 什么是缓存池(Buffer Pool)</h3><ol><li>缓冲池(<code>buffer pool</code>)是一种常见的降低磁盘访问的机制；</li><li>缓冲池通常以页(<code>page</code>)为单位缓存数据；</li><li>缓冲池的常见管理算法是<code>LRU，memcache，OS，InnoDB</code>都使用了这种算法；</li><li><code>InnoDB</code>对普通<code>LRU</code>进行了优化： <ul><li>将缓冲池分为<strong>老生代和新生代</strong>，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题</li><li>页被访问，且在老生代<strong>停留时间超过配置阈值</strong>的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题</li></ul></li></ol><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310182158352.webp" alt="head new-sublist.png" tabindex="0" loading="lazy"><figcaption>head new-sublist.png</figcaption></figure><h3 id="_1-17-简述sql查询过程" tabindex="-1"><a class="header-anchor" href="#_1-17-简述sql查询过程" aria-hidden="true">#</a> 1.17 简述SQL查询过程</h3><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310182200813.webp" alt="优化器.png" tabindex="0" loading="lazy"><figcaption>优化器.png</figcaption></figure><h3 id="_1-18-简述sql更新过程" tabindex="-1"><a class="header-anchor" href="#_1-18-简述sql更新过程" aria-hidden="true">#</a> 1.18 简述SQL更新过程</h3><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310182200028.webp" alt="写入新行.png" tabindex="0" loading="lazy"><figcaption>写入新行.png</figcaption></figure><h3 id="_1-19-什么是脏页" tabindex="-1"><a class="header-anchor" href="#_1-19-什么是脏页" aria-hidden="true">#</a> 1.19 什么是脏页</h3><p>内存数据页和硬盘数据页不一致时，内存页被称为脏页。</p><h3 id="_1-20-innodb锁的类型" tabindex="-1"><a class="header-anchor" href="#_1-20-innodb锁的类型" aria-hidden="true">#</a> 1.20 <code>InnoDB</code>锁的类型</h3><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310182205038.webp" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="_1-21-什么是两阶段锁" tabindex="-1"><a class="header-anchor" href="#_1-21-什么是两阶段锁" aria-hidden="true">#</a> 1.21 什么是两阶段锁</h3><p>在事务中，行锁只在需要时加上，而在事务提交时释放，并不是在不需要时释放。</p><h3 id="_1-22-如何解决死锁" tabindex="-1"><a class="header-anchor" href="#_1-22-如何解决死锁" aria-hidden="true">#</a> 1.22 如何解决死锁</h3><p>当两个事务互相等待时，进入死锁状态，有两种方式解决：</p><ul><li>等待超时，通过<code>innodb_lock_wait_timeout</code>设置</li><li>发起死锁检测，主动回滚死锁链条中的某个事物，让其他事物继续执行。 通过<code>innodb_deadlock_detect</code>设置为 on 开启</li></ul><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310182211996.webp" alt="事务A.png" tabindex="0" loading="lazy"><figcaption>事务A.png</figcaption></figure><h2 id="_2-log" tabindex="-1"><a class="header-anchor" href="#_2-log" aria-hidden="true">#</a> 2. Log</h2><h3 id="_2-1-什么是-binlog" tabindex="-1"><a class="header-anchor" href="#_2-1-什么是-binlog" aria-hidden="true">#</a> 2.1 什么是 <code>binlog</code></h3><p><code>binlog</code>是逻辑日志，记录语句的原始逻辑。</p><ul><li>使用追加写入模式，不覆盖之前的数据，可以提供完整的数据归档能力。</li></ul><h3 id="_2-2-什么是-redo-log" tabindex="-1"><a class="header-anchor" href="#_2-2-什么是-redo-log" aria-hidden="true">#</a> 2.2 什么是 <code>redo log</code></h3><p><code>redo log</code>是物理日志，记录在某个数据页上做了什么修改。</p><ul><li>拥有 <code>crash-safe</code> 能力</li><li>一般只有 4GiB，4个文件，循环复写</li></ul><h3 id="_2-3-binlog和redo-log的区别" tabindex="-1"><a class="header-anchor" href="#_2-3-binlog和redo-log的区别" aria-hidden="true">#</a> 2.3 <code>binlog</code>和<code>redo log</code>的区别</h3><ul><li><code>redo log</code> 为<code>InnoDB</code>独有； <code>binlog</code>为<code>MySQL</code>底层实现，所有的引擎均可使用</li><li><code>redo log</code>为物理日志，记录在数据页上的具体修改； <code>binlog</code>为逻辑日志，记录SQL语句的原始逻辑</li><li><code>redo log</code>采用循环写入，文件大小固定； <code>binlog</code>：采用追加写入，不会覆盖之前的记录</li></ul><h3 id="_2-4-简述binlog的写入机制" tabindex="-1"><a class="header-anchor" href="#_2-4-简述binlog的写入机制" aria-hidden="true">#</a> 2.4 简述<code>binlog</code>的写入机制</h3><p>写入流程：</p><ol><li>事务执行过程中，将日志写入<code>binlog cache</code>(内存中)</li><li>事务提交之后，将<code>binlog cache</code>写入到<code>binlog</code>文件(硬盘中)，清空<code>binlog cache</code></li></ol><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310180855282.webp" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><h3 id="_2-5-简述redo-log的写入机制" tabindex="-1"><a class="header-anchor" href="#_2-5-简述redo-log的写入机制" aria-hidden="true">#</a> 2.5 简述<code>redo log</code>的写入机制</h3><p>写入流程：</p><ol><li>将<code>redo log</code>写入到<code>redo log buffer</code>中</li><li>将<code>buffer</code>的内容写入到文件系统的<code>page cache</code></li><li>调用<code>fsync</code>将<code>page cache</code>的内容持久化到硬盘中</li></ol><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310181834180.webp" alt="Server.png" tabindex="0" loading="lazy"><figcaption>Server.png</figcaption></figure><p><code>InnoDB</code>可以通过<code>innodb_flush_log_at_trx_commit</code>控制<code>redo log</code>的写入：</p><ul><li>为 0 时，表示每次事务提交时，只写入到<code>redo log buffer</code></li><li>为 1 时，表示每次事务提交时，持久化到硬盘</li><li>为 2 时，表示每次事务提交时，写入到<code>page cache</code>中</li></ul><p><code>InnoDB</code>的后台线程，每个 1s ，将<code>redo log buffer</code> 中的日志，调用<code>write</code>写入<code>page cache</code>，然后调用<code>fsync</code>写入硬盘。</p><h3 id="_2-6-简述-redo-log的存储方式-事务没有提交时redo-log会写入到硬盘中吗" tabindex="-1"><a class="header-anchor" href="#_2-6-简述-redo-log的存储方式-事务没有提交时redo-log会写入到硬盘中吗" aria-hidden="true">#</a> 2.6 简述 <code>redo log</code>的存储方式，事务没有提交时<code>redo log</code>会写入到硬盘中吗？</h3><h4 id="存储方式" tabindex="-1"><a class="header-anchor" href="#存储方式" aria-hidden="true">#</a> 存储方式</h4><p><code>redo log</code>只在四个文件中循环写入：</p><ul><li><code>write pos</code>记录当前位置，一边写入一边后移，结束最后一个文件时就从第一个文件开始继续</li><li><code>check point</code>表示当前擦除的位置，移动方式和<code>write pos</code>相同</li><li>两者之间就是新增加的数据，若<code>checkpoint</code>和<code>write pos</code>相遇则表示无法在写入，需要擦除数据</li></ul><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310181844205.webp" alt="write POs.png" tabindex="0" loading="lazy"><figcaption>write POs.png</figcaption></figure><p><code>redo log</code>可以保证数据库异常重启之后，已提交的数据不会丢失，被称为<code>cache safe</code></p><h4 id="未提交事务" tabindex="-1"><a class="header-anchor" href="#未提交事务" aria-hidden="true">#</a> 未提交事务</h4><p>未提交的事务是有可能被写入到硬盘中的：</p><ol><li>当后台线程执行持久化操作时，缓存中的未提交事务<code>redo log</code>会被一起写入硬盘</li><li>当<code>redo log buffer</code>容量达到<code>innodb_log_buffer_size</code>时，后台线程会主动写入<code>page cache</code>，之后可能会被写入硬盘</li><li>当一个线程的<code>innodb_flush_log_at_trx_commit</code>被设置为 1，表示任何提交将直接写入硬盘，此时若缓存中包含其他事务的记录，将被一同写入</li></ol><h3 id="_2-7-简述redo-log组提交-group-commit-机制" tabindex="-1"><a class="header-anchor" href="#_2-7-简述redo-log组提交-group-commit-机制" aria-hidden="true">#</a> 2.7 简述<code>redo log</code>组提交(group commit)机制</h3><p>日志逻辑序列号(log sequence number, LSN)，单调递增，用于表示<code>redo log</code>的写入点，每次写入长度为<code>length</code>的<code>log</code>之后，LSN 将增加<code>length</code>。</p><p>LSN 也会被写到<code>InnoDB</code>数据页中，确保数据页不会被多次执行重复的<code>redo log</code>。</p><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310181854386.webp" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>如上图所示，当事务<code>trx1</code>准备写入硬盘时：</p><ul><li>缓存中<code>trx2</code>,<code>trx3</code>均已完成，<code>LSN</code>此时为 160</li><li>此时会将 160 之前的数据全部写入硬盘</li></ul><p>每次一组提交中，一组事务将会被一次写入硬盘，提高了性能。</p><h3 id="_2-8-binlog和redolog记录如何保持一致" tabindex="-1"><a class="header-anchor" href="#_2-8-binlog和redolog记录如何保持一致" aria-hidden="true">#</a> 2.8 <code>Binlog</code>和<code>Redolog</code>记录如何保持一致</h3><p>进行两段提交，双方会等到两方都写入缓存之后才会开始写入到硬盘中。</p><ol><li><code>redolog</code>写入缓存</li><li><code>binlog</code>写入缓存</li><li><code>redolog</code>写入文件</li><li><code>binlog</code>写入文件</li></ol><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310181902235.webp" alt="log prepore.png" tabindex="0" loading="lazy"><figcaption>log prepore.png</figcaption></figure><h3 id="_2-9-执行一个-update-语句以后-再执行-hexdump-命令直接查看-ibd-文件内容-为什么没有看到数据有改变呢" tabindex="-1"><a class="header-anchor" href="#_2-9-执行一个-update-语句以后-再执行-hexdump-命令直接查看-ibd-文件内容-为什么没有看到数据有改变呢" aria-hidden="true">#</a> 2.9 执行一个 update 语句以后，再执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢</h3><p>这可能是因为<code>WAL</code>机制的原因。<code>update</code>语句执行完成后，<code>InnoDB</code>只保证写完了<code>redo log</code>、内存，可能还没来得及将数据写到磁盘。</p><h3 id="_2-10-为什么-binlog-cache-是每个线程自己维护的-而-redo-log-buffer-是全局共用的" tabindex="-1"><a class="header-anchor" href="#_2-10-为什么-binlog-cache-是每个线程自己维护的-而-redo-log-buffer-是全局共用的" aria-hidden="true">#</a> 2.10 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的</h3><ul><li><code>binlog</code>不能被中断，一个事务的 <code>binlog</code>必须连续写，等到事务完成之后再写入到文件中</li><li><code>redolog</code>没有这种要求，只要有生成<code>redolog</code>就可能被写入到文件中</li></ul><h3 id="_2-11-事务未提交时若发生crash-会导致主备不一致么" tabindex="-1"><a class="header-anchor" href="#_2-11-事务未提交时若发生crash-会导致主备不一致么" aria-hidden="true">#</a> 2.11 事务未提交时若发生crash，会导致主备不一致么</h3><p>不会</p><p><code>binlog</code>和<code>redolog</code>均在缓存中，crash 之后将丢失，但因事务没有提交，所以此时主备数据是一致的</p><h3 id="_2-12-mysql-如何知道binlog是完整的" tabindex="-1"><a class="header-anchor" href="#_2-12-mysql-如何知道binlog是完整的" aria-hidden="true">#</a> 2.12 MySQL 如何知道<code>binlog</code>是完整的</h3><p>一个事务的<code>binlog</code>是存在标识：</p><ul><li><code>statement</code>格式，事务完成后会有<code>COMMIT</code></li><li><code>row</code>格式，事务结束后会有<code>XID event</code></li></ul><p>MySQL 有<code>binlog-checksum</code>参数，用于验证内容的正确性。</p><h3 id="_2-13-redolog和binlog如何关联" tabindex="-1"><a class="header-anchor" href="#_2-13-redolog和binlog如何关联" aria-hidden="true">#</a> 2.13 <code>redolog</code>和<code>binlog</code>如何关联</h3><p>通过<code>XID</code>字段，当发生崩溃恢复时，按顺序扫描<code>redolog</code>：</p><ul><li>若扫描到完整事务，即事务的<code>prepare</code>到<code>commit</code>均存在，则直接提交</li><li>若仅扫描到事务<code>prepare</code>，此时会根据<code>XID</code>在<code>binlog</code>寻找事务</li></ul><h3 id="_2-14-为何binlog和redolog需要进行两段提交-不可以redolog提交之后在提交binlog吗" tabindex="-1"><a class="header-anchor" href="#_2-14-为何binlog和redolog需要进行两段提交-不可以redolog提交之后在提交binlog吗" aria-hidden="true">#</a> 2.14 为何<code>binlog</code>和<code>redolog</code>需要进行两段提交？不可以<code>redolog</code>提交之后在提交<code>binlog</code>吗</h3><p>因为<code>redolog</code>若已经提交，写入到文件中，事务此时无法回滚（若回滚则会覆盖其他的事务）。后续若<code>binlog</code>提交失败，则会导致数据不一致，无法恢复。</p><p>所以，需要两者都提交成功后，在写入到文件中。</p><h3 id="_2-15-可以只用redolog-不用binlog么" tabindex="-1"><a class="header-anchor" href="#_2-15-可以只用redolog-不用binlog么" aria-hidden="true">#</a> 2.15 可以只用<code>redolog</code>，不用<code>binlog</code>么</h3><p>若只考虑崩溃恢复，可以只是用<code>redolog</code>。</p><p>若需要历史记录，则需要<code>binlog</code>。因为<code>redolog</code>时在四个文件中循环写入，会覆盖掉历史数据，造成历史记录丢失。</p><h3 id="_2-16-redolog-buffer是什么" tabindex="-1"><a class="header-anchor" href="#_2-16-redolog-buffer是什么" aria-hidden="true">#</a> 2.16 <code>redolog buffer</code>是什么？</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">begin</span><span class="token punctuation">;</span>\n<span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token keyword">commit</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于事务来说，执行时会将日志写入到缓存<code>redolog buffer</code>中，只有到<code>commit</code>时才会被写入到文件中。</p><h3 id="_2-17-为何binlog不能被中断" tabindex="-1"><a class="header-anchor" href="#_2-17-为何binlog不能被中断" aria-hidden="true">#</a> 2.17 为何<code>binlog</code>不能被中断</h3><p><code>binlog</code>用于记录事务的操作，若事务记录被中断，则破环了事务的原子性特征。</p><h3 id="_2-18-undolog是什么" tabindex="-1"><a class="header-anchor" href="#_2-18-undolog是什么" aria-hidden="true">#</a> 2.18 <code>undolog</code>是什么</h3><p><code>undo</code>用于回滚记录到某个版本，<code>undolog</code>一般是逻辑记录，根据每行进行记录。</p><h3 id="_2-19-简述binlog的三种模式" tabindex="-1"><a class="header-anchor" href="#_2-19-简述binlog的三种模式" aria-hidden="true">#</a> 2.19 简述<code>binlog</code>的三种模式</h3><ol><li><p><code>STATEMENT</code>模式(SBR)：每一条会<strong>修改</strong>数据的SQL语句会记录到<code>binlog</code>中；</p><ul><li>优点是并不需要记录每一条SQL语句和每一行的数据变化，减少日志量。</li><li>缺点是在某些情况下会导致<code>master-slave</code>中的数据不一致(如 <code>sleep()</code>函数， <code>last_insert_id()</code>，以及<code>user-defined functions(udf)</code>等会出现问题)</li></ul><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310182017447.webp" alt="master.000001.png" tabindex="0" loading="lazy"><figcaption>master.000001.png</figcaption></figure></li><li><p><code>ROW</code>模式(RBR)，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改，修改的结果。</p><ul><li>优点：不会出现某些特定情况下的存储过程、或<code>function</code>、或<code>trigger</code>的调用和触发无法被正确复制的问题</li><li>缺点：缺点是会产生大量的日志，尤其是<code>alter table</code>的时候会让日志暴涨</li></ul><figure><img src="https://raw.githubusercontent.com/dreamjz/pics/main/pics/2023/202310182017425.webp" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure></li><li><p><code>MIXED</code>模式(MBR)，以上两种模式的混合使用，一般的复制使用<code>STATEMENT</code>模式保存<code>binlog</code>，对于 <code>STATEMENT</code>模式无法复制的操作使用<code>ROW</code>模式保存<code>binlog</code>，<code>MySQL</code>会根据执行的<code>SQL</code>语句选择日志保存方式</p></li></ol><h3 id="_2-20-mixed模式的好处" tabindex="-1"><a class="header-anchor" href="#_2-20-mixed模式的好处" aria-hidden="true">#</a> 2.20 <code>MIXED</code>模式的好处</h3><p><code>MIXED</code>模式会判断SQL语句是否可能会引起主备不一致，若有可能则使用<code>ROW</code>模式，否则才使用<code>STATEMENT</code>模式。利用了<code>STATEMENT</code>模式的优点又避免了主备不一致的问题。</p>',186),c=[n];function l(r,s){return o(),a("div",null,c)}const p=e(i,[["render",l],["__file","qa_1.html.vue"]]);export{p as default};
