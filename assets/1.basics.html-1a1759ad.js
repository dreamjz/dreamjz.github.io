import{_ as n,Z as a,$ as s,a3 as o}from"./framework-dee406ed.js";const e={},i=o(`<h2 id="_1-select-语句执行流程" tabindex="-1"><a class="header-anchor" href="#_1-select-语句执行流程" aria-hidden="true">#</a> 1. SELECT 语句执行流程</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">// 在 product 表中，查询 id = 1 的记录</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql执行过程/mysql查询流程.png" alt="查询语句执行流程" tabindex="0" loading="lazy"><figcaption>查询语句执行流程</figcaption></figure><p>MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。</li></ul><h2 id="_2-mysql-如何存储一行数据" tabindex="-1"><a class="header-anchor" href="#_2-mysql-如何存储一行数据" aria-hidden="true">#</a> 2. Mysql 如何存储一行数据</h2><p>以<code>InnoDB</code>为例。</p><h3 id="文件位置" tabindex="-1"><a class="header-anchor" href="#文件位置" aria-hidden="true">#</a> 文件位置</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">&#39;datadir&#39;</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------------+-----------------+</span>
<span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span>           <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-----------------+</span>
<span class="token operator">|</span> datadir       <span class="token operator">|</span> <span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>mysql<span class="token operator">/</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-----------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。</p><p>比如，这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@xiaolin ~<span class="token punctuation">]</span><span class="token comment">#ls /var/lib/mysql/my_test</span>
db.opt  
t_order.frm  
t_order.ibd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这三个文件分别代表着：</p><ul><li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li><li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li><li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li></ul><h3 id="表空间文件的结构" tabindex="-1"><a class="header-anchor" href="#表空间文件的结构" aria-hidden="true">#</a> 表空间文件的结构</h3><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong></p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/表空间结构.drawio.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="行-row" tabindex="-1"><a class="header-anchor" href="#行-row" aria-hidden="true">#</a> 行（row）</h4><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p><h4 id="页-page" tabindex="-1"><a class="header-anchor" href="#页-page" aria-hidden="true">#</a> 页（page）</h4><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p><p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的。</p><h4 id="区-extent" tabindex="-1"><a class="header-anchor" href="#区-extent" aria-hidden="true">#</a> 区（extent）</h4><p>InnoDB 存储引擎是用 B+ 树来组织数据的。</p><p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。</p><p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了</strong></p><h4 id="段-segment" tabindex="-1"><a class="header-anchor" href="#段-segment" aria-hidden="true">#</a> 段（segment）</h4><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合</li></ul><h3 id="行格式" tabindex="-1"><a class="header-anchor" href="#行格式" aria-hidden="true">#</a> 行格式</h3><p>行格式（row_format），就是一条记录的存储结构。</p><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</p><ul><li>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。</li><li>由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</li><li>Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。</li></ul><h4 id="compact-格式" tabindex="-1"><a class="header-anchor" href="#compact-格式" aria-hidden="true">#</a> Compact 格式</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" alt="img" loading="lazy">一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。</p><h5 id="记录的额外信息" tabindex="-1"><a class="header-anchor" href="#记录的额外信息" aria-hidden="true">#</a> 记录的额外信息</h5><p>记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。</p><ol><li><strong>变长字段长度列表</strong></li></ol><p>varchar(n) 和 char(n) 的区别是：char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p><p>所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>t_user<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>name<span class="token punctuation">\`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>phone<span class="token punctuation">\`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>age<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> ascii ROW_FORMAT <span class="token operator">=</span> COMPACT<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在 t_user 表里有这三条记录：</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/t_test.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>第一列：</p><ul><li>name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；</li><li>phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；</li><li>age 列和 id 列不是变长字段，所以这里不用管。</li></ul><p>这些变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong>，所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」。</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/变长字段长度列表1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>第二条：</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/变长字段长度列表2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>第三条记录</strong>中 phone 列的值是 NULL，<strong>NULL 是不会存放在行格式中记录的真实数据部分里的</strong>，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/变长字段长度列表3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><p><strong>为什么「变长字段长度列表」的信息要按照逆序存放？</strong></p></blockquote><p>主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p><p>同样的道理， NULL 值列表的信息也需要逆序存放。</p><blockquote><p><strong>每个数据库表的行格式都有「变长字段字节数列表」吗？</strong></p></blockquote><p>其实变长字段字节数列表不是必须的。</p><p><strong>当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了</strong>，因为没必要，不如去掉以节省空间。</p><p>所以「变长字段长度列表」只出现在数据表有变长字段的时候</p><p><strong>2. NULL 值列表</strong></p><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。</p><p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li></ul><p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code>。</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/t_test.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>第一条记录</strong>，第一条记录所有列都有值，不存在 NULL 值：</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null值列表1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null值列表2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>接下来看<strong>第二条记录</strong>，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null值列表3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>最后<strong>第三条记录</strong>，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null值列表4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null值列表5.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><p><strong>每个数据库表的行格式都有「NULL 值列表」吗</strong>？</p></blockquote><p>ULL 值列表也不是必须的。</p><p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p><p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p><blockquote><p><strong>NULL 值列表」是固定 1 字节空间吗？</strong></p></blockquote><p>「NULL 值列表」的空间不是固定 1 字节的。</p><p>当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。</p><p><strong>3. 记录头信息</strong></p><p>头信息内容较多，主要有：</p><ul><li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li><li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul><h5 id="记录的真实数据" tabindex="-1"><a class="header-anchor" href="#记录的真实数据" aria-hidden="true">#</a> 记录的真实数据</h5><p>记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer：</p><ul><li>row_id：如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</li><li>trx_id：事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</li><li>roll_pointer：记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</li></ul><h3 id="varchar-n-中-n-最大取值为多少" tabindex="-1"><a class="header-anchor" href="#varchar-n-中-n-最大取值为多少" aria-hidden="true">#</a> varchar(n) 中 n 最大取值为多少？</h3><p><strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p><p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。</p><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小。要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><h3 id="行溢出后-mysql-是怎么处理的" tabindex="-1"><a class="header-anchor" href="#行溢出后-mysql-是怎么处理的" aria-hidden="true">#</a> 行溢出后，MySQL 是怎么处理的</h3><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。</p><p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/行溢出.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上面这个是 Compact 行格式在发生行溢出后的处理。</p><p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。</p><p>这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：</p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/行溢出2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><blockquote><p>MySQL 的 NULL 值是怎么存放的？</p></blockquote><p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p><p>NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p><blockquote><p>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</p></blockquote><p>MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p><blockquote><p>varchar(n) 中 n 最大取值为多少？</p></blockquote><p>一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p><p>如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。</p><p>计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。</p><p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;= 65535。</p><blockquote><p>行溢出后，MySQL 是怎么处理的？</p></blockquote><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p><p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p>`,120),t=[i];function p(r,l){return a(),s("div",null,t)}const d=n(e,[["render",p],["__file","1.basics.html.vue"]]);export{d as default};
